<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>152.乘积最大子数组</title>
    <link href="/2020/10/16/152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/16/152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> min = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> length = nums.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;length;++i)&#123;            <span class="hljs-keyword">int</span> maxf = max;            <span class="hljs-keyword">int</span> minf = min;            max = Math.max(maxf*nums[i],Math.max(nums[i],minf*nums[i]));            min = Math.min(minf*nums[i],Math.min(nums[i],maxf*nums[i]));            res = Math.max(res,max);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>动态规划</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>150.逆波兰表达式</title>
    <link href="/2020/10/16/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/10/16/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(String[] tokens)</span> </span>&#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        Integer op1,op2;        <span class="hljs-keyword">for</span>(String s:tokens)&#123;            <span class="hljs-keyword">switch</span>(s)&#123;                <span class="hljs-keyword">case</span><span class="hljs-string">&quot;+&quot;</span>:                        op2 = stack.pop();                        op1 = stack.pop();                        stack.push(op2+op1);                        <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span><span class="hljs-string">&quot;-&quot;</span>:                        op2 = stack.pop();                        op1 = stack.pop();                        stack.push(op1-op2);                        <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span><span class="hljs-string">&quot;*&quot;</span>:                    op2 = stack.pop();                    op1 = stack.pop();                    stack.push(op2*op1);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span><span class="hljs-string">&quot;/&quot;</span>:                    op2 = stack.pop();                    op1 = stack.pop();                    stack.push(op1/op2);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    stack.push(Integer.valueOf(s));                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.pop();    &#125;&#125;</code></pre><h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h1><p>优化之后，用switch，就是用栈，有操作符号，返回前两个数然后进行操作，在入栈。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>148.排序链表</title>
    <link href="/2020/10/16/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/16/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode quick = head.next;        ListNode slow = head;        <span class="hljs-keyword">while</span>(quick != <span class="hljs-keyword">null</span> &amp;&amp; quick.next != <span class="hljs-keyword">null</span>)&#123;            quick = quick.next.next;            slow = slow.next;        &#125;        ListNode temp = slow.next;        slow.next = <span class="hljs-keyword">null</span>;        ListNode left = sortList(head);        ListNode right = sortList(temp);        ListNode cur = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode res = cur;        <span class="hljs-keyword">while</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(left.val &lt; right.val)&#123;                cur.next = left;                left = left.next;            &#125;<span class="hljs-keyword">else</span>&#123;                cur.next = right;                right = right.next;            &#125;            cur = cur.next;        &#125;        cur.next = (left!= <span class="hljs-keyword">null</span>)?left:right;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>归并排序，快慢指针找到中间节点。然后进行递归排序。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146.LRU缓存机制</title>
    <link href="/2020/10/16/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/16/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;   LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    HashMap&lt;Integer,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">int</span> size;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;        list.addFirst(number);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;        list.remove(<span class="hljs-keyword">new</span> Integer(number));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span></span>&#123;        remove(number);        addNode(number);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> list.pollLast();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.capacity = capacity;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hashmap.containsKey(key))&#123;            moveToHead(key);            <span class="hljs-keyword">return</span> hashmap.get(key);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hashmap.containsKey(key))&#123;            hashmap.put(key,value);            moveToHead(key);        &#125;<span class="hljs-keyword">else</span>&#123;            hashmap.put(key,value);            addNode(key);            size++;        &#125;        <span class="hljs-keyword">if</span>(size &gt; capacity)&#123;            <span class="hljs-keyword">int</span> number = popTail();            hashmap.remove(number);            --size;        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><span class="hljs-comment"> * int param_1 = obj.get(key);</span><span class="hljs-comment"> * obj.put(key,value);</span><span class="hljs-comment"> */</span></code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>逻辑</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>144.二叉树的前序遍历</title>
    <link href="/2020/10/15/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/15/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        TreeNode pre = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;                pre = root.left;                <span class="hljs-keyword">while</span>(pre.right != <span class="hljs-keyword">null</span>  &amp;&amp; pre.right != root)&#123;                    pre =pre.right;                &#125;                <span class="hljs-keyword">if</span>(pre.right == <span class="hljs-keyword">null</span>)&#123;                    pre.right = root;                    res.add(root.val);                    root = root.left;                &#125;<span class="hljs-keyword">else</span>&#123;                                        pre.right = <span class="hljs-keyword">null</span>;                    root = root.right;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                res.add(root.val);                root =root.right;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实跟中序遍历，非递归没什么区别的，就是什么时候加入这个值，很有说道。中序遍历时，当该pre节点已经指向了root，这个时候在把节点的值加入。前序遍历的时候，如果pre没有指向root，这个时候加入。大同小异其实都一样的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>143.重排链表</title>
    <link href="/2020/10/15/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/15/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> ;        &#125;        ListNode first = head;        ListNode last = head;        <span class="hljs-keyword">while</span>(last  != <span class="hljs-keyword">null</span> &amp;&amp; last.next != <span class="hljs-keyword">null</span>)&#123;            first = first.next;            last = last.next.next;;        &#125;        ListNode newHead = first.next;        first.next = <span class="hljs-keyword">null</span>;        ListNode newnode = reverse(newHead);        ListNode result = head;        <span class="hljs-keyword">while</span>(newnode != <span class="hljs-keyword">null</span>)&#123;            ListNode temp  = newnode.next;            newnode.next = head.next;            head.next = newnode;            head = newnode.next;            newnode = temp;        &#125;    &#125;    ListNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> pre;        &#125;        ListNode next = head.next;        head.next = pre;        pre = head;        head = next;        <span class="hljs-keyword">return</span> reverse(head);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>好不容易有一道自己做出来差不多的题了，首先利用快慢指针找到中点，然后反转中点后面的链表的，然后相当于并归两个链表。</p>]]></content>
    
    
    <categories>
      
      <category>mid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142.环形链表二</title>
    <link href="/2020/10/15/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/"/>
    <url>/2020/10/15/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode meet = core(head);        <span class="hljs-keyword">if</span>(meet == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode first = head;        <span class="hljs-keyword">while</span>(first != meet)&#123;            first= first.next;            meet = meet.next;        &#125;        <span class="hljs-keyword">return</span> meet;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">core</span><span class="hljs-params">(ListNode head)</span></span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode first = head;        ListNode last = head;        <span class="hljs-keyword">while</span>(last != <span class="hljs-keyword">null</span> &amp;&amp; last.next != <span class="hljs-keyword">null</span>)&#123;            first = first.next;            last = last.next.next;            <span class="hljs-keyword">if</span>(first == last)&#123;                <span class="hljs-keyword">return</span> first;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>找到第一次相遇的地方（快慢指针）、</p><p>然后从head头部和第一次相遇的地方遍历，什么时候再次相遇就是环的入口。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141.环形链表</title>
    <link href="/2020/10/15/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/15/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123;</span><span class="hljs-comment"> *         val = x;</span><span class="hljs-comment"> *         next = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;           ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        pre.next = head;        ListNode first = pre;        ListNode last = pre;        <span class="hljs-keyword">while</span>(last != <span class="hljs-keyword">null</span> &amp;&amp; last.next != <span class="hljs-keyword">null</span>)&#123;            last = last.next.next;            first = first.next;            <span class="hljs-keyword">if</span>(last == first)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>快慢指针</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>139.单词拆分</title>
    <link href="/2020/10/15/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2020/10/15/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;        HashSet&lt;String&gt; hashset = <span class="hljs-keyword">new</span> HashSet(wordDict);        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()+<span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=s.length();++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;i;++j)&#123;                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; hashset.contains(s.substring(j,i)))&#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>动态规划</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>137.只出现一次的数字二</title>
    <link href="/2020/10/15/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E4%BA%8C/"/>
    <url>/2020/10/15/137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num :nums)&#123;            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;                <span class="hljs-keyword">if</span>((num &amp; mask) != <span class="hljs-number">0</span>)&#123;                    result[i]++;                &#125;                mask &lt;&lt;=<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;++i)&#123;            res &lt;&lt;=<span class="hljs-number">1</span>;            res +=result[i]%<span class="hljs-number">3</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>因为是int类型，相当于有32个位置，来存储当前每个位出现多少次，因为其他每个数都出现3次，所以%3就知道哪位多了。最后返回res</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136.只出现一次的数字</title>
    <link href="/2020/10/15/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/10/15/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i :nums)&#123;            result ^=i;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>因为任何一个人异或他本身都等于0，所以每个数字除了那个数字都出现了两次。所有的数字都异或一次就可以。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>125.验证回文串</title>
    <link href="/2020/10/15/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2020/10/15/125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        s= s.toLowerCase();        <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> last = s.length()-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(first&lt;=last)&#123;            <span class="hljs-keyword">while</span>(!((s.charAt(first) &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s.charAt(first) &lt;=<span class="hljs-string">&#x27;z&#x27;</span>) || (s.charAt(first) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(first) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)))&#123;                first++;                <span class="hljs-keyword">if</span>(first&gt;last)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">while</span>(!((s.charAt(last) &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s.charAt(last) &lt;=<span class="hljs-string">&#x27;z&#x27;</span>) || (s.charAt(last) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(last) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)))&#123;                last--;                <span class="hljs-keyword">if</span>(first&gt;last)&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(first &lt;= last &amp;&amp;  s.charAt(first) != s.charAt(last))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            first++;            last--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>简单的逻辑判断。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121.买卖股票的最佳时机</title>
    <link href="/2020/10/15/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2020/10/15/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> minprice = prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;prices.length;++i)&#123;            <span class="hljs-keyword">if</span>(prices[i] &lt;minprice)&#123;                minprice = prices[i];            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prices[i] - minprice &gt; max)&#123;                max = prices[i] - minprice;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这题是比较简单的题，照理说用动态规划。但是可以加快，就不用动态规划了。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>114.二叉树展开为链表</title>
    <link href="/2020/10/15/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/15/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        core(root);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;list.size();++i)&#123;            TreeNode pre = list.get(i-<span class="hljs-number">1</span>);            TreeNode cur = list.get(i);            pre.left =<span class="hljs-keyword">null</span>;            pre.right =cur;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        list.add(root);        core(root.left);        core(root.right);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>先把所有的节点放在一个list中，然后遍历去进行，左边为null，右边为下一个节点。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>109.有序链表转换二叉搜索树</title>
    <link href="/2020/10/15/109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/15/109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;       &#125;        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;           list.add(head.val);       &#125;       <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();++i)&#123;           nums[i] = list.get(i);       &#125;       <span class="hljs-keyword">return</span> core(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">if</span>(start&gt;end)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        root.left = core(nums,start,mid-<span class="hljs-number">1</span>);        root.right = core(nums,mid+<span class="hljs-number">1</span>,end);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">return</span> core(head,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">core</span><span class="hljs-params">(ListNode left,ListNode right)</span></span>&#123;        <span class="hljs-keyword">if</span>(left == right)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode mid = coreMid(left,right);        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(mid.val);        node.left = core(left,mid);        node.right = core(mid.next,right);        <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">coreMid</span><span class="hljs-params">(ListNode left,ListNode right)</span></span>&#123;        ListNode fast = left;        ListNode slow = left;        <span class="hljs-keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;            fast=  fast.next;            fast = fast.next;            slow = slow.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一种方法是我的题解，相当于把链表转换成为数组，然后根据上一题的方式，进行递归得到最后的答案。但是时间复杂度特别高，击败了7%的用户。</p><p>第二种方法也是需要这么做，但是不用转换成数组了，直接用链表去做，找到中间的元素就用快慢指针去做即可。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>108.将有序数组转换成为二叉搜索树</title>
    <link href="/2020/10/15/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/15/108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">return</span> core(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">if</span>(start&gt;end)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;         <span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);        root.left = core(nums,start,mid-<span class="hljs-number">1</span>);        root.right = core(nums,mid+<span class="hljs-number">1</span>,end);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是一种递归，二叉搜索树，要保证两边高度相差不超过1.</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105.从前序和中序遍历构造二叉树</title>
    <link href="/2020/10/15/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/10/15/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">if</span> (preorder == <span class="hljs-keyword">null</span> || preorder.length == <span class="hljs-number">0</span> || inorder == <span class="hljs-keyword">null</span> || inorder.length == <span class="hljs-number">0</span> || preorder.length != inorder.length) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> core(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder,<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> pe,<span class="hljs-keyword">int</span>[] inorder,<span class="hljs-keyword">int</span> is,<span class="hljs-keyword">int</span> ie)</span></span>&#123;        <span class="hljs-keyword">if</span>(ps&gt;pe || is&gt;ie)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[ps]);        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;preorder.length;++i)&#123;            <span class="hljs-keyword">if</span>(preorder[ps] == inorder[is+i])&#123;                index = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        root.left = core(preorder,ps+<span class="hljs-number">1</span>,ps+index,inorder,is,is+index-<span class="hljs-number">1</span>);        root.right = core(preorder,ps+index+<span class="hljs-number">1</span>,pe,inorder,is+index+<span class="hljs-number">1</span>,ie);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>做过好多遍了，要考虑开始与结束。</p><p>还有这个index记住，是加的索引，不是哪里截止了。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104.二叉树的最大深度</title>
    <link href="/2020/10/15/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2020/10/15/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> core(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">core</span><span class="hljs-params">(TreeNode root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left = core(root.left);        <span class="hljs-keyword">int</span> right = core(root.right);        <span class="hljs-keyword">return</span> Math.max(left,right)+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>挺简单的，就是遍历出一个深度。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>103.二叉树的锯齿层次遍历</title>
    <link href="/2020/10/15/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/15/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        LinkedList&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        list.add(root);        <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(!list.isEmpty())&#123;            <span class="hljs-keyword">int</span> size = list.size();            LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;size;++i)&#123;                TreeNode cur = list.pollLast();                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>)&#123;                    list.addFirst(cur.left);                &#125;                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>)&#123;                    list.addFirst(cur.right);                &#125;                <span class="hljs-keyword">if</span>((level&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;                    queue.addFirst(cur.val);                &#125;<span class="hljs-keyword">else</span>&#123;                    queue.addLast(cur.val);                &#125;                            &#125;            lists.add(queue);            level++;        &#125;        <span class="hljs-keyword">return</span> lists;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>用一个双向链表即可，用size判断奇数还是偶数，然后用linkedlist从前边还是后边去加。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>102.二叉树的层次遍历</title>
    <link href="/2020/10/15/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/15/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        LinkedList&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        list.add(root);        <span class="hljs-keyword">while</span>(!list.isEmpty())&#123;            LinkedList&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();            <span class="hljs-keyword">while</span>(!list.isEmpty())&#123;                stack.addFirst(list.pollLast());            &#125;            List&lt;Integer&gt; arraylist = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;                TreeNode cur = stack.pollLast();                arraylist.add(cur.val);                <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>)&#123;                    list.addFirst(cur.left);                &#125;                <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>)&#123;                    list.addFirst(cur.right);                &#125;            &#125;            lists.add(arraylist);        &#125;        <span class="hljs-keyword">return</span> lists;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>自己有点愚蠢在里面加了一层双向链表去做，其实用size得到当前有多少节点，然后遍历出来就行了</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101.对称二叉树</title>
    <link href="/2020/10/15/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/10/15/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> core(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">core</span><span class="hljs-params">(TreeNode first,TreeNode last)</span></span>&#123;        <span class="hljs-keyword">if</span>(first == <span class="hljs-keyword">null</span> &amp;&amp; last == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span>(first == <span class="hljs-keyword">null</span> || last == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(first.val != last.val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> core(first.left,last.right) &amp;&amp; core(first.right,last.left);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>没什么难的，就是判断是否对称二叉树，左边的与右边（数值）是否相等。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98.验证二叉搜索树</title>
    <link href="/2020/10/15/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/15/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span>  core(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">core</span><span class="hljs-params">(TreeNode root,Integer top,Integer bot)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span>(bot != <span class="hljs-keyword">null</span> &amp;&amp; root.val&lt;=bot)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(top != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= top)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(!core(root.left,root.val,bot))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(!core(root.right,top,root.val))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>递归，对于左子树来说，不能大于他的父节点，对于右子树来说，不能小于他的父节点。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>95.不同的二叉搜索树</title>
    <link href="/2020/10/15/95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2020/10/15/95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     TreeNode left;</span><span class="hljs-comment"> *     TreeNode right;</span><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = left;</span><span class="hljs-comment"> *         this.right = right;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        &#125;        <span class="hljs-keyword">return</span> core(<span class="hljs-number">1</span>,n);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">if</span>(start&gt;end)&#123;            list.add(<span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> list;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start;i&lt;=end;++i)&#123;            List&lt;TreeNode&gt; lefts = core(start,i-<span class="hljs-number">1</span>);            List&lt;TreeNode&gt; rights = core(i+<span class="hljs-number">1</span>,end);            <span class="hljs-keyword">for</span>(TreeNode left:lefts)&#123;                <span class="hljs-keyword">for</span>(TreeNode right:rights)&#123;                    TreeNode cur = <span class="hljs-keyword">new</span> TreeNode(i);                    cur.left = left;                    cur.right = right;                    list.add(cur);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>对于1来说，左边就是null了，右边是list包含（2~5），所以这种排列也有很多种可怜，就用递归去慢慢递归，然后得出结果。</p><p>有一个误区就是list不是总体的list，而是单独的一个list作为return的结果。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>94.二叉树的中序遍历</title>
    <link href="/2020/10/14/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/10/14/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs vbscript">/** * Definition <span class="hljs-keyword">for</span> a binary tree node. * <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> TreeNode &#123; *     <span class="hljs-built_in">int</span> val; *     TreeNode <span class="hljs-built_in">left</span>; *     TreeNode <span class="hljs-built_in">right</span>; *     TreeNode() &#123;&#125; *     TreeNode(<span class="hljs-built_in">int</span> val) &#123; this.val = val; &#125; *     TreeNode(<span class="hljs-built_in">int</span> val, TreeNode <span class="hljs-built_in">left</span>, TreeNode <span class="hljs-built_in">right</span>) &#123; *         this.val = val; *         this.<span class="hljs-built_in">left</span> = <span class="hljs-built_in">left</span>; *         this.<span class="hljs-built_in">right</span> = <span class="hljs-built_in">right</span>; *     &#125; * &#125; */<span class="hljs-keyword">class</span> Solution &#123;        <span class="hljs-keyword">public</span> List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        TreeNode pre = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">if</span>(root.<span class="hljs-built_in">left</span> != <span class="hljs-literal">null</span>)&#123;                pre = root.<span class="hljs-built_in">left</span>;                <span class="hljs-keyword">while</span>(pre.<span class="hljs-built_in">right</span> != <span class="hljs-literal">null</span>  &amp;&amp; pre.<span class="hljs-built_in">right</span> != root)&#123;                    pre =pre.<span class="hljs-built_in">right</span>;                &#125;                <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">right</span> == <span class="hljs-literal">null</span>)&#123;                    pre.<span class="hljs-built_in">right</span> = root;                    root = root.<span class="hljs-built_in">left</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    res.add(root.val);                    pre.<span class="hljs-built_in">right</span> = <span class="hljs-literal">null</span>;                    root = root.<span class="hljs-built_in">right</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                res.add(root.val);                root =root.<span class="hljs-built_in">right</span>;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>mirrors算法，首先root是根，先看他是否有左节点，如果有，pre首先为他的左节点，然后这个时候一直根据pre向右遍历，直到这个pre的右节点为空（那么就设置当前pre的右节点连接到root上面，然后把root = root.left）,如果当前右节点已经指向了root，那么打印出这个节点，把这个节点右节点重新指向空，并且root = root.right。如果左节点为空，那么直接说明已经到了叶子节点，list.add（root.val）即可，然后root = root.right</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>92.反转链表二</title>
    <link href="/2020/10/14/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%BA%8C/"/>
    <url>/2020/10/14/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> reverse(head,n);        &#125;<span class="hljs-keyword">else</span>&#123;            head.next =  reverseBetween(head.next,m-<span class="hljs-number">1</span>,n-<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> head;    &#125;    ListNode pre = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            pre = head.next;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode last = reverse(head.next,n-<span class="hljs-number">1</span>);        head.next.next = head;        head.next = pre;        <span class="hljs-keyword">return</span> last;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这是一个看到的算法，用递归的方式去做很简单的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>91.解码方法</title>
    <link href="/2020/10/14/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <url>/2020/10/14/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length()&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(chars[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;chars.length;++i)&#123;            <span class="hljs-keyword">if</span>(chars[i] != <span class="hljs-string">&#x27;0&#x27;</span>)&#123;                dp[i] = dp[i-<span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">10</span> *(chars[i-<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>) + chars[i]-<span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">if</span>(temp &lt;=<span class="hljs-number">26</span> &amp;&amp; temp &gt;=<span class="hljs-number">10</span>)&#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;                    dp[i]++;                &#125;<span class="hljs-keyword">else</span>&#123;                    dp[i] +=dp[i-<span class="hljs-number">2</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>动态规划，如果当前的数字大于等于10并且小于等于26那么说明，他可以凑成一个组合。dp[i]+=dp[i-2].</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>88.合并两个有序数组</title>
    <link href="/2020/10/14/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/14/88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = m+n-<span class="hljs-number">1</span> ;         m = m-<span class="hljs-number">1</span>;         n = n-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(m &gt;=<span class="hljs-number">0</span> &amp;&amp; n &gt;=<span class="hljs-number">0</span> )&#123;            <span class="hljs-keyword">if</span>(nums1[m] &gt;nums2[n])&#123;                nums1[count] = nums1[m--];            &#125;<span class="hljs-keyword">else</span>&#123;                nums1[count] = nums2[n--];            &#125;            count--;        &#125;        <span class="hljs-keyword">while</span>(m &gt;=<span class="hljs-number">0</span> &amp;&amp; n&lt;<span class="hljs-number">0</span>)&#123;            nums1[count--] = nums1[m--];        &#125;        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">0</span> &amp;&amp; m&lt;<span class="hljs-number">0</span>)&#123;            nums1[count--] = nums2[n--];        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>要记住，可能存在一个数组已经到头了，但是另一个数组还有数组存在的情况，所以要根据剩余的进行一次放到数组nums1中。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>86.分隔链表</title>
    <link href="/2020/10/14/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/14/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;        ListNode before_head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode before = before_head;        ListNode after_head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode after = after_head;        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(head.val &lt;x)&#123;                before.next = head;                before = before.next;            &#125;<span class="hljs-keyword">else</span>&#123;                after.next = head;                after = after.next;            &#125;            head =head.next;        &#125;        after.next =<span class="hljs-keyword">null</span>;        before.next = after_head.next;        <span class="hljs-keyword">return</span> before_head.next;    &#125;&#125;</code></pre><h1 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h1><p>新建两个链表，然后根据这两个链表在进行排列。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>83.删除排序链表中的重复元素</title>
    <link href="/2020/10/14/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/10/14/83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode result = head;                <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; head.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span> &amp;&amp; head.next != <span class="hljs-keyword">null</span> &amp;&amp; head.val == head.next.val)&#123;                head.next = head.next.next;            &#125;            head = head.next;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一次while判断之后，第二次while也要判断一次。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>79.单词搜索</title>
    <link href="/2020/10/14/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2020/10/14/79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;        <span class="hljs-keyword">int</span> row = board.length;        <span class="hljs-keyword">int</span> col = board[<span class="hljs-number">0</span>].length;        Boolean[][] flag =<span class="hljs-keyword">new</span> Boolean[row][col];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;row;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;col;++j) &#123;                flag[i][j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;row;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;col;++j)&#123;                <span class="hljs-keyword">if</span>(Core(board,word,<span class="hljs-number">0</span>,flag,row,col,i,j))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Core</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,String word,<span class="hljs-keyword">int</span> index,Boolean[][] flag,<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> col,<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> cols)</span></span>&#123;        <span class="hljs-keyword">if</span>(index == word.length())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span>(rows &gt;=<span class="hljs-number">0</span> &amp;&amp; rows&lt; row &amp;&amp; cols &gt;=<span class="hljs-number">0</span> &amp;&amp; cols&lt;col &amp;&amp; flag[rows][cols] == <span class="hljs-keyword">false</span> &amp;&amp; board[rows][cols] ==word.charAt(index))&#123;            flag[rows][cols] = <span class="hljs-keyword">true</span>;            result = Core(board,word,index+<span class="hljs-number">1</span>,flag,row,col,rows+<span class="hljs-number">1</span>,cols)||                    Core(board,word,index+<span class="hljs-number">1</span>,flag,row,col,rows-<span class="hljs-number">1</span>,cols)||                    Core(board,word,index+<span class="hljs-number">1</span>,flag,row,col,rows,cols+<span class="hljs-number">1</span>)||                    Core(board,word,index+<span class="hljs-number">1</span>,flag,row,col,rows,cols-<span class="hljs-number">1</span>);            flag[rows][cols] =<span class="hljs-keyword">false</span>;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>相当于遍历整个图</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>78.子集</title>
    <link href="/2020/10/14/78-%E5%AD%90%E9%9B%86/"/>
    <url>/2020/10/14/78-%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        core(nums,<span class="hljs-keyword">new</span> ArrayList(),<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,List&lt;Integer&gt; list,<span class="hljs-keyword">int</span> index)</span></span>&#123;        lists.add(<span class="hljs-keyword">new</span> ArrayList(list));        <span class="hljs-keyword">if</span>(list.size() == nums.length)&#123;            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;nums.length;++i)&#123;            list.add(nums[i]);            core(nums,list,i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>遍历，全排列，所有有一个list为[]</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>75.颜色分类</title>
    <link href="/2020/10/13/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2020/10/13/75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> last = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;=last;++i)&#123;            <span class="hljs-keyword">while</span>(i&lt;=last &amp;&amp; nums[i] == <span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">int</span> temp = nums[i];                nums[i] = nums[last];                nums[last] = temp;                --last;            &#125;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">int</span> temp = nums[i];                nums[i] = nums[first];                nums[first] = temp;                first++;             &#125;        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>采用的是双指针的思想，因为后面的指针后面一直就是2，前面的指针就是1，所以while判断是为了如果超过last指针的，直接跳出循环即可。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70.爬楼梯</title>
    <link href="/2020/10/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2020/10/13/70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">int</span> f1 = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> f2 = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">int</span> temp = f1+f2;            f1 = f2;            f2= temp;        &#125;        <span class="hljs-keyword">return</span> f2;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这个需要考虑用中间变量去存，如果用数组的话，太占用空间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>69.x的平方根</title>
    <link href="/2020/10/13/69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2020/10/13/69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = x;        <span class="hljs-keyword">int</span> ans = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)mid*mid &lt;=x)&#123;                ans = mid;                left = mid+<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                right = mid-<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：一定记住比较的使用用long在外面扩上，防止溢出。</p><p>第二：比较的时候，如果当前值已经小于等于，把left要置位mid+1;如果大于把right置位mid-1。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64.最小路径和</title>
    <link href="/2020/10/13/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2020/10/13/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">if</span>(grid == <span class="hljs-keyword">null</span> || grid.length &lt;=<span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> length = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;grid.length;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;++j)&#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)&#123;                    dp[j] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;                    dp[j] = dp[j-<span class="hljs-number">1</span>]+grid[i][j];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;                    dp[j] +=grid[i][j];                &#125;<span class="hljs-keyword">else</span>&#123;                    dp[j] = Math.min(dp[j],dp[j-<span class="hljs-number">1</span>])+grid[i][j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>dp，要求是最小路径</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>62.不同路径</title>
    <link href="/2020/10/13/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/10/13/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)&#123;                    dp[j] = <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    dp[j] += dp[j-<span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>一位数组的dp即可。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>61.旋转链表</title>
    <link href="/2020/10/13/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/13/61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span>(head.next ==<span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-keyword">int</span> n;        ListNode oldnode = head;        <span class="hljs-keyword">for</span>(n=<span class="hljs-number">1</span>;oldnode.next != <span class="hljs-keyword">null</span> ;++n)&#123;            oldnode = oldnode.next;        &#125;        oldnode.next = head;        ListNode newnode = head;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>;i  &lt; n-k % n-<span class="hljs-number">1</span>;++i)&#123;            newnode = newnode.next;        &#125;        ListNode result = newnode.next;        newnode.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实我一直百思不得其解这个，n-k%n-1是怎么来的。</p><p>因为是向右移动，自己画个图就能画出来。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>56.合并区间</title>
    <link href="/2020/10/13/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/10/13/56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;        List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(intervals == <span class="hljs-keyword">null</span> || intervals.length &lt;= <span class="hljs-number">0</span> || intervals[<span class="hljs-number">0</span>].length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);        &#125;        Arrays.sort(intervals,(o1,o2) -&gt; o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(index &lt; intervals.length)&#123;            <span class="hljs-keyword">int</span> left = intervals[index][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> right = intervals[index][<span class="hljs-number">1</span>];            <span class="hljs-keyword">while</span>(index+<span class="hljs-number">1</span> &lt;intervals.length &amp;&amp; intervals[index+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;= right)&#123;                right = Math.max(right,intervals[index+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                index++;            &#125;            list.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left,right&#125;);            index++;        &#125;        <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>][]);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一个是list转换成数组的时候toArray() ，参数可以是泛型，表明转换成什么类型的。</p><p>第二个倒是里面的逻辑，别忘了每次while或者list.add之后，都需要把索引index++。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>55.跳跃游戏</title>
    <link href="/2020/10/13/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2020/10/13/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(dp[i])&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=nums[i];++j)&#123;                    <span class="hljs-keyword">if</span>((i+j) &gt;= nums.length-<span class="hljs-number">1</span>)&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                    &#125;                    dp[i+j] = <span class="hljs-keyword">true</span>;            &#125;            &#125;                    &#125;        <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>] == <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(i&lt;=target)&#123;                target = Math.max(target,i+nums[i]);                <span class="hljs-keyword">if</span>(target &gt;= nums.length-<span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一种是我自己用dp做出来的，时间复杂度和空间复杂度都特别高。</p><p>第二种是参考别人的方法做出来的，判断能达到的最大值是否到达数组的最后一个。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>54.螺旋矩阵</title>
    <link href="/2020/10/13/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2020/10/13/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length &lt;= <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> list;        &#125;        <span class="hljs-keyword">int</span> height = matrix.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> width = matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> bot = matrix.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right &amp;&amp; top&lt;=bot)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left;i&lt;=right;++i)&#123;                list.add(matrix[top][i]);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = top+<span class="hljs-number">1</span>;i&lt;=bot;++i)&#123;                list.add(matrix[i][right]);            &#125;            <span class="hljs-keyword">if</span>(left&lt;right &amp;&amp; top &lt; bot)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = right-<span class="hljs-number">1</span>;i&gt;left;--i)&#123;                    list.add(matrix[bot][i]);                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = bot;i&gt;top;--i)&#123;                    list.add(matrix[i][left]);                &#125;            &#125;            left++;            right--;            top++;            bot--;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>考虑left,right,top,bot四个阈值。</p><p>用大while循环，去过滤left&lt;=right,top=bot</p><p>还要考虑小范围的东西，有的时候并没有元素了，所以有if(left&lt;right &amp;&amp; top &lt; bot)判断</p>]]></content>
    
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子序和</title>
    <link href="/2020/10/13/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2020/10/13/53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> target = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)&#123;                target = nums[i];            &#125;<span class="hljs-keyword">else</span>&#123;                target +=nums[i];            &#125;            max = Math.max(max,target);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>判断逻辑挺简单的，如果当前target小于0，那么直接舍弃，若不，累加。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>50.Pow(x,n)</title>
    <link href="/2020/10/13/50-Pow-x-n/"/>
    <url>/2020/10/13/50-Pow-x-n/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;        &#125;        <span class="hljs-keyword">long</span> N = n;        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/compute(x,-N);        &#125;        <span class="hljs-keyword">return</span> compute(x,N);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">long</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>( n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-keyword">if</span>(n% <span class="hljs-number">2</span>== <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">double</span> half = compute(x,n/<span class="hljs-number">2</span>);            <span class="hljs-keyword">return</span> half * half;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">double</span> half = compute(x,n/<span class="hljs-number">2</span>);            <span class="hljs-keyword">return</span> half* half*x;        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：考虑这个参数应该为long类型</p><p>第二：考虑时间复杂度，用递归的思想去计算这个值。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49.字母异位词分组</title>
    <link href="/2020/10/13/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/10/13/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;     List&lt;List&lt;String&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span> || strs.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        HashMap&lt;String,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;strs.length;++i)&#123;            String string = strs[i];            <span class="hljs-keyword">char</span>[] nowchar = string.toCharArray();            Arrays.sort(nowchar);            String target = <span class="hljs-keyword">new</span> String(nowchar);            <span class="hljs-keyword">if</span>(hashmap.containsKey(target))&#123;                <span class="hljs-keyword">int</span> index = hashmap.get(target);                lists.get(index).add(string);            &#125;<span class="hljs-keyword">else</span>&#123;                hashmap.put(target,count++);                List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                list.add(string);                lists.add(list);            &#125;        &#125;        <span class="hljs-keyword">return</span> lists;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>利用一个hashmap存放key为String类型的单词，value存放索引（索引存放于在lists里面的索引）。</p><p>然后每次传入新的string之后，利用Arrays.sort()方法去进行排序，之后进行比较。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48.旋转图像</title>
    <link href="/2020/10/13/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/10/13/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> length = matrix.length;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;length;++j)&#123;                <span class="hljs-keyword">int</span> temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;length/<span class="hljs-number">2</span>;++j)&#123;                <span class="hljs-keyword">int</span> temp = matrix[i][j];                matrix[i][j] = matrix[i][length-j-<span class="hljs-number">1</span>];                matrix[i][length-j-<span class="hljs-number">1</span>] = temp;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>先是根据对角线进行一次翻转，然后再根据中轴线进行每一行的翻转，最后得到了这个图形。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46.全排列</title>
    <link href="/2020/10/12/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/10/12/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        core(<span class="hljs-number">0</span>,nums);        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">if</span>(index == nums.length-<span class="hljs-number">1</span>)&#123;            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i :nums)&#123;                list.add(i);            &#125;            lists.add(list);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;nums.length;++i)&#123;                swap(i,index,nums);                core(index+<span class="hljs-number">1</span>,nums);                swap(i,index,nums);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = nums[start];        nums[start] = nums[end];        nums[end] = temp;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>全排列问题，就是相当于每个数进行一次排列，排列这种数组常用的方式是交换swap，同样的像组合排列一样，需要在swap回来。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>40.组合总和</title>
    <link href="/2020/10/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2020/10/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(candidates == <span class="hljs-keyword">null</span> || candidates.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;                Arrays.sort(candidates);        core(<span class="hljs-keyword">new</span> ArrayList(),<span class="hljs-number">0</span>,candidates,target);        HashSet&lt;List&lt;Integer&gt;&gt; hashset = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(lists);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(hashset);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(List&lt;Integer&gt; list,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target)</span></span>&#123;               <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;            lists.add (<span class="hljs-keyword">new</span> ArrayList(list));            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;candidates.length;++i)&#123;            <span class="hljs-keyword">if</span>(target-candidates[i] &lt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(i&gt;index &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(candidates[i]);            core(list,i+<span class="hljs-number">1</span>,candidates,target-candidates[i]);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这道题与上一道组合排列其实很相似，只不过现在是不要可重复的数字了。</p><p>我一直用没有剪枝的方式，这样导致时间复杂度会很高，剪枝的逻辑就跟三数之和一样。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39.组合总和</title>
    <link href="/2020/10/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2020/10/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(candidates == <span class="hljs-keyword">null</span> || candidates.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        Arrays.sort(candidates);        core(<span class="hljs-keyword">new</span> ArrayList(),candidates,target,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(List&lt;Integer&gt; list,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> index)</span></span>&#123;        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;            lists.add(<span class="hljs-keyword">new</span> ArrayList(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;candidates.length;++i)&#123;            list.add(candidates[i]);            core(list,candidates,target-candidates[i],i);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这道题是可以选取重复的数字，所以在递归循环中，index为i，而不是i+1</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>38.外观数组</title>
    <link href="/2020/10/12/38-%E5%A4%96%E8%A7%82%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/12/38-%E5%A4%96%E8%A7%82%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;        &#125;        StringBuffer stringbuffer = <span class="hljs-keyword">new</span> StringBuffer();        String string = countAndSay(n-<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> length = string.length();        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=length;++i)&#123;            <span class="hljs-keyword">if</span>(i == length)&#123;                stringbuffer.append(i-index).append(string.charAt(index)).toString();            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string.charAt(i) != string.charAt(index))&#123;                stringbuffer.append(i-index).append(string.charAt(index));                index = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> stringbuffer.toString();    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>首先这是一个递归的题，n==1的时候，字符串只有“1”，然后慢慢的往上去叠。</p><p>剩下的就是一个逻辑的事情了，index一开始是记录0，下面就是每次记录位移的距离与当前这个数字是多少，然后用stringbuffer进行叠加。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35.搜索插入位置</title>
    <link href="/2020/10/12/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/10/12/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt;= target)&#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums.length;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>挺简单的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34.在排序数组中查找第一个和最后一个位置</title>
    <link href="/2020/10/12/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/10/12/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> left = coreFirst(nums,target);        <span class="hljs-keyword">int</span> right = coreLast(nums,target);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left,right&#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coreFirst</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;             <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span>(target == nums[mid])&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span>&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target)&#123;            <span class="hljs-keyword">return</span> left;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coreLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;             <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span>(target == nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span>&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-keyword">if</span>(right != -<span class="hljs-number">1</span> &amp;&amp; nums[right] == target)&#123;            <span class="hljs-keyword">return</span> right;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实这道题一开始，我的想法并不对，用二分法找到对于二分法来说第一次出现的值，然后用–/++操作，找到这个值的开头和结尾，其实这样的时间复杂度根本不是logn，就是要利用二分法一直进行二分查找才可以。</p><p>那么还是定义两个函数，第一个找第一个位置，第二个找最后一个位置这样。有一种情况是需要特殊考虑的，就是3 4 5 5 这种情况，如果让你去找6这个target，最后也会导致left&gt;right循环退出，所以要判断一下 left != nums.length，如果相等，其实也是没找到，只不过只是数组越界了无法找到。</p><p>找第一个出现的位置的时候，left可能回到nums.length，找最后一个出现位置的时候，right可能会到-1，这些都是需要思考的事情。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33.搜索旋转排序数组</title>
    <link href="/2020/10/12/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/12/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(left&lt;=right)&#123;            <span class="hljs-keyword">int</span> mid =(left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;=nums[mid])&#123;                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;=target &amp;&amp; target&lt;=nums[mid])&#123;                    right = mid-<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    left = mid+<span class="hljs-number">1</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(nums[mid] &lt;=target &amp;&amp; target &lt;=nums[right])&#123;                    left = mid+<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    right = mid-<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是有一个点是一个旋转点，比如1 2 3 4 5 6 7 8 9</p><p>可能旋转成 8 9 1 2 3 4 5 6 7，也可能旋转成 3 4 5 6 7 8 9 1 2</p><p>关于这个中心点mid，就有两种不同的算法，如果在第一种nums[right] &gt;= nums[mid]，再如果target在介于中间，那么left = mid+1；如果不介于，那么right = mid-1，这样同样适用于 nums[left] &lt;= nums[mid] 也就是后者。</p><p>再用递归的思想，进行这道题的编写。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31.下一个排列</title>
    <link href="/2020/10/12/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2020/10/12/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =nums.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i+<span class="hljs-number">1</span>])&#123;                index = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;            reverse(<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,nums);            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;            <span class="hljs-keyword">if</span>(nums[j] &gt;nums[index])&#123;                swap(index,j,nums);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        reverse(index+<span class="hljs-number">1</span>,nums.length-<span class="hljs-number">1</span>,nums);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = nums[left];        nums[left] = nums[right];        nums[right] = temp;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">while</span>(left&lt;right)&#123;            swap(left,right,nums);            left++;            right--;        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>个人认为这这种题就是看了才会</p><p>首先从后面往前找第一个当前位置比后一个位置小的数，记住该索引。</p><p>再从后面往前再找第一个比刚才内个索引大的这个位置，然后进行交换。</p><p>最后在从索引后面位置的一个，到结尾，进行翻转，得到正解。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <link href="/2020/10/12/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2020/10/12/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] != nums[j])&#123;                j++;                nums[j] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> j+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>双指针问题，如果当前位置i,j的值都一样，i继续，j不动，什么时候值不同，让j移到下一个位置，然后把当前位置j的值换成i，最后返回j+1，因为返回的是新的长度，所以j是从开始的，所以为j+1</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="/2020/10/12/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/12/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode first = head;        ListNode second = head.next;                first.next = swapPairs(second.next);        second.next = first;                <span class="hljs-keyword">return</span> second;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是一个递归问题，弄明白就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.合并k个升序链表</title>
    <link href="/2020/10/12/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/12/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode pre = result;                PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(            (o1,o2) -&gt;o1.val-o2.val        );        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;lists.length;++i)&#123;            <span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-keyword">null</span>)&#123;                queue.add(lists[i]);            &#125;        &#125;        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;            ListNode newnode = queue.poll();            pre.next = newnode;            pre =pre.next;            <span class="hljs-keyword">if</span>(newnode.next != <span class="hljs-keyword">null</span>)&#123;                queue.add(newnode.next);            &#125;        &#125;        <span class="hljs-keyword">return</span> result.next;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这是一道hard的类型题，我取巧用了优先级队列java中的api，记住一定要重写o1,o2也就是里面的规则。</p><p>然后其他的倒是没什么难度。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.有效的括号</title>
    <link href="/2020/10/12/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2020/10/12/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;                stack.push(s.charAt(i));            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty()  &amp;&amp; (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span>) || (s.charAt(i) == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) || (s.charAt(i) == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span>))&#123;                stack.pop();            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>考虑使用栈这种数据结构，先进后出。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <link href="/2020/10/12/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/12/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        result.next = head;        ListNode first= result;        ListNode second = result;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;            first = first.next;            n--;        &#125;        <span class="hljs-keyword">while</span>(first.next != <span class="hljs-keyword">null</span>)&#123;            first = first.next;            second = second.next;        &#125;        second.next = second.next.next;        <span class="hljs-keyword">return</span> result.next;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>像这种倒数链表的题，一般都要建立一个前驱节点指向头结点，再按照逻辑去做，进行递归或者是其他操作，得到题解。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.电话号码的字母组合</title>
    <link href="/2020/10/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2020/10/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;String,String&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits == <span class="hljs-keyword">null</span> || digits.length()&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> list;        &#125;        hashmap.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>);        core(<span class="hljs-string">&quot;&quot;</span>,digits);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(String temp,String res)</span></span>&#123;        <span class="hljs-keyword">if</span>(res.length() == <span class="hljs-number">0</span>)&#123;            list.add(temp);        &#125;<span class="hljs-keyword">else</span>&#123;            String number = res.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);            String choose = hashmap.get(number);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;choose.length();i++)&#123;                String newletter = temp + choose.substring(i,i+<span class="hljs-number">1</span>);                core(newletter,res.substring(<span class="hljs-number">1</span>));            &#125;        &#125;            &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：把所有的数字放入到hashmap中，形成一个key为number的字符串，value为真正字母的字符串。</p><p>第二： 相当于一次全排列，每次递归循环，出口就是需要遍历的字符串的长度为0</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和</title>
    <link href="/2020/10/12/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/10/12/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;                List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(nums);        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;<span class="hljs-number">3</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(nums[i] &gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> lists;            &#125;            <span class="hljs-keyword">int</span> left = i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> target = -nums[i];            <span class="hljs-keyword">while</span>(left&lt;right)&#123;                <span class="hljs-keyword">if</span>(nums[left] + nums[right] == target)&#123;                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                    list.add(nums[i]);                    list.add(nums[left]);                    list.add(nums[right]);                    lists.add(list);                    right--;                    left++;                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>])&#123;                        right--;                    &#125;                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="hljs-number">1</span>])&#123;                        left++;                    &#125;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left] + nums[right] &gt;target)&#123;                    right--;                &#125;<span class="hljs-keyword">else</span>&#123;                    left++;                   &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> lists;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：一定要先进行排序</p><p>第二：一定进行剪枝，分别是第一个数已经大于0了，还有当得到一组等于0的解，继续向下剪枝。</p><p>第三：一定判断边界条件。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最长公共前缀</title>
    <link href="/2020/10/12/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2020/10/12/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span> || strs.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        &#125;        StringBuffer string = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;strs[<span class="hljs-number">0</span>].length();++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;strs.length;++j)&#123;                <span class="hljs-keyword">if</span>(i &gt;=strs[j].length() || strs[j].charAt(i) != strs[<span class="hljs-number">0</span>].charAt(i))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(string);                &#125;            &#125;            string.append(strs[<span class="hljs-number">0</span>].charAt(i));        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(string);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是双层遍历，直接获取到结果。注意边界情况的判断即可。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.盛最多水的容器</title>
    <link href="/2020/10/12/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/10/12/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length&lt;<span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;right)&#123;            <span class="hljs-keyword">int</span> width = right-left;            <span class="hljs-keyword">int</span> high = height[left]&gt;height[right]?height[right--]:height[left++];            <span class="hljs-keyword">int</span> temp  = high*width;            max = Math.max(max,temp);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是双指针的用法，哪边小，从哪边往右走。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.回文数</title>
    <link href="/2020/10/12/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/10/12/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>( x == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span>(x &lt;<span class="hljs-number">0</span> || x%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(temp &lt; x)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            x = x/<span class="hljs-number">10</span>;            temp = temp*<span class="hljs-number">10</span>+tmp;        &#125;                <span class="hljs-keyword">return</span> (temp == x) || (temp/<span class="hljs-number">10</span> == x);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>只需要相当于翻转一下，到一半即可，判断是不是回文数。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.整数反转</title>
    <link href="/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span>(temp &gt; Integer.MAX_VALUE/<span class="hljs-number">10</span> || (temp == Integer.MAX_VALUE &amp;&amp; tmp &gt;=Integer.MAX_VALUE%<span class="hljs-number">10</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>(temp &lt; Integer.MIN_VALUE/<span class="hljs-number">10</span> || (temp == Integer.MIN_VALUE/<span class="hljs-number">10</span> &amp;&amp;  tmp &lt;= Integer.MIN_VALUE%<span class="hljs-number">10</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            temp = temp*<span class="hljs-number">10</span>+tmp;            x = x/<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> temp;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是需要考虑一下整数溢出的情况，其他的就是一个翻转的过程。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length()&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;​    &#125;​    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;​    String result = <span class="hljs-string">&quot;&quot;</span>;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;​      String a = core(i,i,s);​      String b = core(i,i+<span class="hljs-number">1</span>,s);​      String temp = a.length()&gt;b.length()?a:b;​      <span class="hljs-keyword">if</span>(temp.length() &gt; length)&#123;​        result = temp;​        length = temp.length();​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,String s)</span></span>&#123;​    <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;​      left--;​      right++;​    &#125;​    <span class="hljs-keyword">return</span> s.substring(left+<span class="hljs-number">1</span>,right);  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在于substring的这个函数你需要的left+1这个参数，包括开始索引，到结束索引的前一个（所以就是不包含最后的索引），其他没有什么想要说的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length()&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​    &#125;​    HashMap&lt;Character,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;​      <span class="hljs-keyword">int</span> temp = hashmap.getOrDefault(s.charAt(i),-<span class="hljs-number">1</span>);​      tmp = i-temp&gt;tmp?tmp+<span class="hljs-number">1</span>:i-temp;​      max = Math.max(max,tmp);​      hashmap.put(s.charAt(i),i);​    &#125;​    <span class="hljs-keyword">return</span> max;  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实这是一道动态规划的题，只不过加入了hashmap每次记录上一次单词出现的位置。</p><p>当前位置-上一次单词出现的位置与tmp中间量作为比较。如果大于，说明上一个单词不在当前的tmp中了，所以tmp+1；如果小于，说明上一个单词在tmp中，那么相当于进行了一次替换。</p><p>最后max是中间变量，从头到尾贯彻，作为最大值。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.两数相加</title>
    <link href="/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"></span><span class="hljs-comment"> \* Definition for singly-linked list.</span><span class="hljs-comment"></span><span class="hljs-comment"> \* public class ListNode &#123;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   int val;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode next;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \* &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span> &amp;&amp; l2 == <span class="hljs-keyword">null</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;​    &#125;​    ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);​    ListNode pre = result;​    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;​      <span class="hljs-keyword">int</span> val1 = l1 == <span class="hljs-keyword">null</span> ?<span class="hljs-number">0</span>:l1.val;​      <span class="hljs-keyword">int</span> val2 = l2 == <span class="hljs-keyword">null</span> ?<span class="hljs-number">0</span>:l2.val;​      <span class="hljs-keyword">int</span> temp = val1+val2+flag;​      ListNode newnode = <span class="hljs-keyword">new</span> ListNode(temp%<span class="hljs-number">10</span>);​      flag = temp / <span class="hljs-number">10</span>;​      pre.next = newnode;​      pre = pre.next;​      <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>)&#123;​        l1 = l1.next;​      &#125;​      <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>)&#123;​        l2 = l2.next;​      &#125;​    &#125;​    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;​      ListNode newnode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);​      pre.next =newnode;​    &#125;​    <span class="hljs-keyword">return</span> result.next;  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>没什么好说的，就是一开始用result作为最后输出的结尾，然后while的判断逻辑是l1,l2是否为空，最后判断一下当前的flag</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;​    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];​    &#125;​    HashMap&lt;Integer,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;​      <span class="hljs-keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;​        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,hashmap.get(target-nums[i])&#125;;​      &#125;<span class="hljs-keyword">else</span>&#123;​        hashmap.put(nums[i],i);​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是用hashmap记录一下值，如果target-当前值存在于hashmap中，那么直接返回包括这两个数的索引。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程的状态与转换</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的定义，组成，组织方式，特征</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201011160211832.png"></p><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><p>程序：就是一个指令序列</p><p>早起计算机的时候，只支持单道程序，内存里面只有一个程序在跑，分为程序段（程序代码）和数据段（变量）。</p><p>引入多道程序之后，内存可以有多道程序运行，各个程序的代码、运算数据存放的位置不同，操作系统需要怎么才能找到程序的存放位置呢。</p><p>操作系统在每一个进程执行之前，都会创建一个叫PCB（进程控制块）的这样的一个东西，用来描述进程当前的信息。</p><p>程序段，数据段，pcb三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上创建进程实体中的pcb，而撤销进程，实质上也是撤销进程实体中的pcb</p><p>注意：<strong>pcb是进程存在的唯一标志</strong></p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><p>代码本身，指令序列</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>程序运行时使用、产生的运算数据。如全局变量，局部变量，宏定义的常量都存放在数据段内。</p><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>操作系统通过pcb来管理进程，因此pcb中应该包含操作系统对其进程管理所需的各种信息（相当于进程运行的元信息）。</p><p><img src="image-20201011161046798.png"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p>在一个系统中，通常有十级到千级的pcb，为了能对他们加以有效的管理，应该用适当的方式把这些pcb组织起来。</p><p>上面讲到的，进程的组成是哪几个部分组成了进程，进程的组织，是讲多进程之间的组织方式</p><p>一共分为两种：链接方式和索引方式</p><p><img src="image-20201011161413822.png"></p><h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p><img src="image-20201011161508401.png"></p><p>一共有三种指针，</p><p>执行指针：指向当前处于就绪态的进程</p><p>就绪队列指针：当前排队的进程，会根据优先级高低进行排列</p><p>阻塞队列指针：指向当前处阻塞态的进程</p><h2 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h2><p>同样也有三个指针，只不过指向的是一个表，而表中还会指向相应的pcb</p><p><img src="image-20201011162142337.png"></p><h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><p><img src="image-20201011162208795.png"></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201011162418120.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里规约禁止使用java内置Executors创建线程池</title>
    <link href="/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="提出几个问题"><a href="#提出几个问题" class="headerlink" title="提出几个问题"></a>提出几个问题</h1><p>1）线程池存在的意义</p><p>2）Executors创建线程池一共几种方式</p><p>3）ThreadPoolExecutor对象</p><p>4）线程池执行的逻辑和线程池参数关系</p><p>5）OOM会发生么</p><p>6）如何定义线程池参数</p><h1 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h1><p>线程池可以复用线程，每个线程的创建与销毁其实都会耗费资源的，所以有了池的概念，可以节省一些资源。</p><p>1）减少资源创建，减少内存开销</p><p>2）降低系统开销，创建线程需要时间，会延迟处理请求的速度</p><p>3）提高稳定性，避免无限创建线程引起的OOM（outofmemory）</p><h1 id="使用Exectors静态函数创建线程池"><a href="#使用Exectors静态函数创建线程池" class="headerlink" title="使用Exectors静态函数创建线程池"></a>使用Exectors静态函数创建线程池</h1><ul><li><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h1 id="Java的线程池"><a href="#Java的线程池" class="headerlink" title="Java的线程池"></a>Java的线程池</h1><p>在探究之前，我们需要明确一下，线程池的创建以及比较核心的七大参数。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                              <span class="hljs-keyword">int</span> maximumPoolSize,                              <span class="hljs-keyword">long</span> keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?                <span class="hljs-keyword">null</span> :                AccessController.getContext();        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;        <span class="hljs-keyword">this</span>.workQueue = workQueue;        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;    &#125;<span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), <span class="hljs-keyword">handler</span>);&#125;</code></pre><p>corePoolSize: 核心线程数</p><p>maximumPoolSize： 最大线程数</p><p>keepAliveTime： 非核心线程数，多长时间会被销毁</p><p>unit： 时间单位</p><p>workQueue： 任务队列，阻塞队列，用于存放已经提交但是未被执行的任务</p><p>threadFactory：线程工厂，用于创建线程</p><p>handler： 拒绝策略，任务想要添加进入线程池，线程池拒绝该任务所采取的相应策略</p><h1 id="workingQueue任务队列"><a href="#workingQueue任务队列" class="headerlink" title="workingQueue任务队列"></a>workingQueue任务队列</h1><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作，反之亦然。</p><p>4.PriorityBlockingQueue：具有优先级别的阻塞队列。</p><p>5.DelayedWorkQueue：延迟的阻塞队列。</p><h1 id="handler拒绝策略"><a href="#handler拒绝策略" class="headerlink" title="handler拒绝策略"></a>handler拒绝策略</h1><p>1.AbortPolicy：直接抛出异常，<strong>默认策略</strong></p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</p><p>4.DiscardPolicy：直接丢弃任务</p><h1 id="为什么阿里规约要求手动创建线程池"><a href="#为什么阿里规约要求手动创建线程池" class="headerlink" title="为什么阿里规约要求手动创建线程池"></a>为什么阿里规约要求手动创建线程池</h1><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>第一种newFixedThreadPool和newSingleThreadExecutor用的workingQueue都是LinkedBlockingQueue都是无界的阻塞队列，所以如果生产者一直大于消费者，队列不断膨胀，可能会导致内存溢出。</p><p>第二种newCachedThreadPool使用的是SynchronousQueue和newScheduledThreadPool使用的是DelayedWorkQueue。其中maximumPoolSize参数都为Integer.MAX_VALUE，所以空闲线程存活时间为0，当添加任务的速度大于线程池处理任务的速度，可能会创建大量的线程，消耗资源，甚至导致OOM。</p><h1 id="线程池执行任务逻辑"><a href="#线程池执行任务逻辑" class="headerlink" title="线程池执行任务逻辑"></a>线程池执行任务逻辑</h1><p>提交任务，如果当前核心线程没满，创建核心线程执行任务。若满了，看任务队列是否满，若无，添加队列。若已满，创建非核心线程执行任务，如果当前非核心线程也已经满了，那么进入到拒绝策略。</p>]]></content>
    
    
    <categories>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用 （六）</title>
    <link href="/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009205529316.png" alt="image-20201009205529316"></p><h1 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h1><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口，其中，程序接口由一组系统调用组成。</p><p>供给应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务，系统中各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配，IO操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p><img src="image-20201009211304714.png" alt="image-20201009211304714"></p><h1 id="系统调用和库函数的作用"><a href="#系统调用和库函数的作用" class="headerlink" title="系统调用和库函数的作用"></a>系统调用和库函数的作用</h1><p><img src="image-20201009211411935.png" alt="image-20201009211411935"></p><p>普通的应用程序可能调用库函数，库函数可能调用系统调用，也可能不调用系统调用。</p><h1 id="系统调用的背后的过程"><a href="#系统调用的背后的过程" class="headerlink" title="系统调用的背后的过程"></a>系统调用的背后的过程</h1><p>高级语言编译之后会变成汇编语言。</p><p><img src="image-20201009211748305.png" alt="image-20201009211748305"></p><p>传递系统调用参数 ——》 执行陷入指令（用户态） ——》 执行系统调用相应服务程序（核心态）——》返回用户程序</p><p>注意：</p><p>1）陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而cpu进入核心态</p><p>2）发出系统调用的请求是在用户态的，而对系统调用的相应处理是在核心态下进行的。</p><p>3） <strong>陷入指令是唯一一个在用户态下执行，而不能在核心态下面执行的指令</strong> </p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009212119178.png" alt="image-20201009212119178"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断和异常 （五）</title>
    <link href="/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009145255238.png" alt="image-20201009145255238"></p><h1 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h1><p>早起的计算机，比如博文操作系统的发展讲解的，单道处理系统，一次只能处理一个程序。所以各个程序只能串行的执行，系统资源利用率比较低。</p><p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p><p>举个例子，如果有多道程序运行，会有一个计时器，记录运行的时间。cpu收到计时部件发出的中断信号，切换为核心态为中断信号进行处理。操作系统内核会对中断信号进行处理，接受之后发现进程一的时间片时间到了，轮到进程二执行。进程二运行之后，发出系统调用（内中断信号），请求输出。cpu切换到内核态，对中断进行处理。进程二暂停等到打印机IO，换到进程三运行。等到打印机IO完成，设备向cpu发送外中断信号，cpu接收到io设备发来的中断信号，切换为核心态对中断进行处理。</p><h1 id="中断的概念和应用"><a href="#中断的概念和应用" class="headerlink" title="中断的概念和应用"></a>中断的概念和应用</h1><p>中断发生后，cpu会从用户态进入到内核态</p><p>中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</p><p>对于不同的中断信号，会进行不同的处理</p><p>发生了中断，就意味着操作系统介入，开展管理工作，由于操作系统的管理工作（比如进程切换、分配io设备等）需要使用特权指令，因此cpu要从用户态转换为内核态，中断可以使cpu从用户态切换为核心态，使操作系统或得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><p>用户态到核心态的切换，只能通过中断实现的，并且是唯一的方式。</p><p>核心态到用户态的转换，通过程序状态字psw标志位标识的。</p><h1 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h1><p><img src="image-20201009170728978.png" alt="image-20201009170728978"></p><h2 id="外中断处理过程"><a href="#外中断处理过程" class="headerlink" title="外中断处理过程"></a>外中断处理过程</h2><p><img src="image-20201009171311786.png" alt="image-20201009171311786"></p><p>执行完每一个指令的时候，cpu都要检查当前是否有外部中断信号。</p><p>如果检测到了外部中断信号，则需要保护被中断进程的cpu环境（程序状态字psw，程序计数器pc，各种寄存器状态）</p><p>根据中断信号类型转入相应的中断处理程序</p><p>恢复原进程的cpu环境并退出中断，返回原进程继续往下执行</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009171956319.png" alt="image-20201009171956319"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的运行机制与体系结构 （四）</title>
    <link href="/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009114046283.png"></p><h1 id="预备知识：指令"><a href="#预备知识：指令" class="headerlink" title="预备知识：指令"></a>预备知识：指令</h1><p>高级语言代码会被编译/解释之后变成机器语言指令（二进制）</p><p>一条高级语言的代码翻译过来可能会对应多条指令。</p><p><img src="image-20201009114232710.png"></p><p>上图可以看到，简单的一个让x加1的代码，对应了三条指令。</p><p>所以，指令也就是cpu能识别，执行的最基本的命令。</p><h2 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h2><p><img src="image-20201009114400229.png"></p><p>根据指令的优先级，我们可以把指令分成如上图的两种，特权指令（加法）与非特权指令（开辟空间）。</p><p>特权指令不允许普通用户执行，cpu执行的时候需要判断一下，当前的用户是否可以执行这条指令。</p><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><p><img src="image-20201009114522933.png"></p><p>用户态，就是普通用户，无法执行特权指令。核心态，指令都可以执行。</p><p>那么这个状态是用程序状态寄存器（psw）中的某标志位来标识当前处理器应该处于什么状态，如0是用户态，1是内核态。</p><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><p>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p><p>应用程序：为了保证系统安全的运行，普通应用程序只能执行非特权指令，运行在用户态。</p><h2 id="总结回顾指令"><a href="#总结回顾指令" class="headerlink" title="总结回顾指令"></a>总结回顾指令</h2><p><img src="image-20201009114855863.png"></p><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="image-20201009143510101.png"></p><p>时钟管理：实现计时功能</p><p>原语：是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性。</p><p>内核是计算机上的底层软件，是操作系统最基本、最核心的部分。</p><p>实现操作系统内核功能的那些程序就是内核程序。</p><p><img src="image-20201009143659151.png"></p><h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><p><img src="image-20201009143758466.png"></p><p>分为大内核与微内核。</p><p>大内核：高性能，但是内核代码庞大</p><p>微内核：内核功能少，结构清晰，但是如果需要一些调度，内核态和用户态之间需要频繁的进行切换，性能低。</p><p>这地方的理解就跟公司的管理层一样，大公司组织架构清晰，而小公司的leader可能要处理很多事情。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009144239267.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的发展 （三）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008230507825.png"></p><h1 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h1><p>计算机能识别二进制数（01），把数写在纸带机上，让计算机进行读取，处理之后，再输出纸带机上，最后输出。计算机的处理速度快，但是纸带机速度很慢，这样cpu空闲时间很多。另外，程序用纸袋机，这样不太方便。人机速度矛盾导致资源利用率低。</p><h1 id="单道批处理阶段"><a href="#单道批处理阶段" class="headerlink" title="单道批处理阶段"></a>单道批处理阶段</h1><p>引入脱机输入/输出技术（用磁带完成）并监督程序负责控制作业的输入/输出，速度比纸带机快很多。</p><p>单道批处理系统的优点：缓解了一定程度的人机矛盾，资源利用率有所提升。</p><p>缺点：内存中仅仅能有一道程序运行，只是该程序运行之后才能调入下一道程序。cpu还是有大量的时间空闲，资源利用虽然提高但是还是很低。</p><h1 id="多道批处理阶段"><a href="#多道批处理阶段" class="headerlink" title="多道批处理阶段"></a>多道批处理阶段</h1><p>还是利用磁带完成，但是是多道程序。操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行，各个程序并发执行。</p><p>优点：多道程序并发执行，共享计算机资源。资源利用率大幅度提升，cpu和其他资源保持忙碌状态，系统吞吐量增大。</p><p>缺点：没有人机交互，用户响应时间长（用户提交作业之后只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h1 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h1><p>计算机以时间片为单位轮流的为各个用户/作业服务，各个用户可以通过终端与计算机进行交互。</p><p>缺点：不能优先处理一些紧急任务，操作系统对所有的用户和作业都是公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h1 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h1><p>优先响应一些紧急任务，某些紧急任务不需要时间排队。</p><p>在实时操作系统的控制下，计算机接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><h1 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h1><h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机结合起来，实现数据传送等功能，实现网络中各种资源的共享（文件的共享）和各台计算机之间的通信。</p><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>主要特点是分布性和并行性，系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行/协同完成这个任务。</p><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><p>windows xp / MacOs 方便个人使用</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009113711074.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的四个特征 （二）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008223341290.png"></p><p>并发和共享是最基本的两个特征，二者互为存在条件。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发是指两个或者多个事件在同一个时间间隔内发生，这些事件宏观上是同时发生的，但是在微观上其实是互相交替发生的（一个cpu运行两个进程）。</p><p>特别注意的是并行，指两个或者多个事件在同一时刻同时发生（双核cpu执行两个进程）。</p><p>操作系统的并发性，是指计算机系统中同时存在着多个运行着的程序。</p><p>一个单核处理机（cpu）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但是宏观看上去就好像在同时执行）。事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p><p>当今的计算机，虽然cpu有很多核，但是操作系统的并发性还是必不可少的，远远不够使用。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><p>共享即是共享资源，是指系统中的资源可供内存中多个并发执行的进程使用。</p><p>资源分为两种，互斥共享与同时共享。</p><p>互斥共享，是指同一时间只能允许一个进程访问资源。</p><p>同时共享，是指同一时间允许多个进程访问资源。</p><p>生活中的实例，互斥共享——摄像头，同时共享——发送文件。</p><h1 id="共享与并发"><a href="#共享与并发" class="headerlink" title="共享与并发"></a>共享与并发</h1><p>并发性是指计算机系统中同时存在着多个运行的程序。</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>并发和共享是互为存在条件的。</p><h1 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h1><p>是指把一个物理上的实体对应为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受的。</p><p>一个程序需要分配内存才能运行，一个游戏如果8G，电脑有4G内存。程序同时运行内存远超于4G，利用了<strong>虚拟存储器技术</strong>，所以可以同时运行。（空分复用技术）</p><p>多个程序需要被分配多个cpu才能运行，单核的cpu是如何运行程序的呢？采用的是<strong>虚拟处理器技术</strong>，使用户看起来一共有6个cpu在同时服务。（时分复用技术）</p><p><img src="image-20201008225118513.png"></p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步是指，在多道程序下，允许多个程序并发执行，但是由于资源有限，进程的执行不一定是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008225444396.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的概念（定义）目标与功能 （一）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="大家都熟悉的操作系统"><a href="#大家都熟悉的操作系统" class="headerlink" title="大家都熟悉的操作系统"></a>大家都熟悉的操作系统</h1><p>如下图，我们可以看到常用的操作系统。不管是pc端还是移动端。</p><p><img src="image-20201008110624343.png"></p><h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008110710543.png"></p><h1 id="操作系统的概念和定义"><a href="#操作系统的概念和定义" class="headerlink" title="操作系统的概念和定义"></a>操作系统的概念和定义</h1><p>一台电脑的诞生：一台裸机  ——》 安装windows操作系统 ——》安装游戏 ——》启动游戏进行游戏</p><p>硬件有我们的cpu/内存/硬盘</p><p>应用程序有我们常用的微信QQ百度云</p><p>那么操作系统的概念与定义我们可想而知。</p><p>1）负责管理协同硬件/软件等计算机资源的工作</p><p>2）为上层的应用程序，用户提高简单易用的服务</p><p>3）操作系统是系统软件，不是硬件</p><p>结合以上三条就是：</p><p><strong>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机中最基本的系统软件。</strong></p><p><img src="image-20201008110858123.png"></p><h1 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h1><h2 id="作为系统资源的管理者"><a href="#作为系统资源的管理者" class="headerlink" title="作为系统资源的管理者"></a>作为系统资源的管理者</h2><p>补充一个小知识，如果我们使用QQ与朋友进行聊天。</p><p>第一步：找到QQ文件的位置（路径） <strong>文件管理</strong> 打开找到QQ.exe这个程序的存放位置</p><p>第二步：双击打开exe文件  <strong>存储器管理</strong> 需要把相应的程序加载到内存中</p><p>第三步：QQ程序开始运行 <strong>处理器管理</strong> 对应的进程被处理器管理</p><p>第四步：开始使用QQ聊天 <strong>设备管理</strong> 分配给QQ聊天（就比如我们使用牛客网进行面试的时候，只能一个网页开启视频）</p><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p>命令接口： 允许用户使用</p><p>程序接口： 允许用户通过程序间接调用</p><p>gui： 图像化界面</p><h3 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h3><p>联机命令接口：用户说一句，系统做一句。cmd</p><p>脱机命令接口：用户说一堆，系统做一堆。shell脚本</p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>允许用户通过程序间接调用，由一组系统调用组成（程序接口=系统调用）</p><p>程序中调用user32.dll（该调用过程为系统调用，系统调用又称为广义指令）</p><h3 id="gui图形用户界面"><a href="#gui图形用户界面" class="headerlink" title="gui图形用户界面"></a>gui图形用户界面</h3><p>不需要参数，只需要鼠标与键盘的配合即可</p><h2 id="作为最接近硬件的层次"><a href="#作为最接近硬件的层次" class="headerlink" title="作为最接近硬件的层次"></a>作为最接近硬件的层次</h2><p>通常把覆盖软件的机器成为扩充机器，又称之为虚拟机。</p><p>硬件都是一些零零散散的，而操作系统就可以利用这些硬件工具做想做的事情，封装思想。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008140933785.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/06/hello-world/"/>
    <url>/2020/10/06/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>程序人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
