<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>46.全排列</title>
    <link href="/2020/10/12/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/10/12/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        core(<span class="hljs-number">0</span>,nums);        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">if</span>(index == nums.length-<span class="hljs-number">1</span>)&#123;            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i :nums)&#123;                list.add(i);            &#125;            lists.add(list);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;nums.length;++i)&#123;                swap(i,index,nums);                core(index+<span class="hljs-number">1</span>,nums);                swap(i,index,nums);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = nums[start];        nums[start] = nums[end];        nums[end] = temp;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>全排列问题，就是相当于每个数进行一次排列，排列这种数组常用的方式是交换swap，同样的像组合排列一样，需要在swap回来。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>40.组合总和</title>
    <link href="/2020/10/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2020/10/12/40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(candidates == <span class="hljs-keyword">null</span> || candidates.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;                Arrays.sort(candidates);        core(<span class="hljs-keyword">new</span> ArrayList(),<span class="hljs-number">0</span>,candidates,target);        HashSet&lt;List&lt;Integer&gt;&gt; hashset = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(lists);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(hashset);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(List&lt;Integer&gt; list,<span class="hljs-keyword">int</span> index,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target)</span></span>&#123;               <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;            lists.add (<span class="hljs-keyword">new</span> ArrayList(list));            <span class="hljs-keyword">return</span> ;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;candidates.length;++i)&#123;            <span class="hljs-keyword">if</span>(target-candidates[i] &lt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">if</span>(i&gt;index &amp;&amp; candidates[i] == candidates[i-<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(candidates[i]);            core(list,i+<span class="hljs-number">1</span>,candidates,target-candidates[i]);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这道题与上一道组合排列其实很相似，只不过现在是不要可重复的数字了。</p><p>我一直用没有剪枝的方式，这样导致时间复杂度会很高，剪枝的逻辑就跟三数之和一样。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39.组合总和</title>
    <link href="/2020/10/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2020/10/12/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(candidates == <span class="hljs-keyword">null</span> || candidates.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        Arrays.sort(candidates);        core(<span class="hljs-keyword">new</span> ArrayList(),candidates,target,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> lists;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(List&lt;Integer&gt; list,<span class="hljs-keyword">int</span>[] candidates,<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> index)</span></span>&#123;        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;            lists.add(<span class="hljs-keyword">new</span> ArrayList(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index;i&lt;candidates.length;++i)&#123;            list.add(candidates[i]);            core(list,candidates,target-candidates[i],i);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这道题是可以选取重复的数字，所以在递归循环中，index为i，而不是i+1</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>38.外观数组</title>
    <link href="/2020/10/12/38-%E5%A4%96%E8%A7%82%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/12/38-%E5%A4%96%E8%A7%82%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;        &#125;        StringBuffer stringbuffer = <span class="hljs-keyword">new</span> StringBuffer();        String string = countAndSay(n-<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> length = string.length();        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=length;++i)&#123;            <span class="hljs-keyword">if</span>(i == length)&#123;                stringbuffer.append(i-index).append(string.charAt(index)).toString();            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string.charAt(i) != string.charAt(index))&#123;                stringbuffer.append(i-index).append(string.charAt(index));                index = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> stringbuffer.toString();    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>首先这是一个递归的题，n==1的时候，字符串只有“1”，然后慢慢的往上去叠。</p><p>剩下的就是一个逻辑的事情了，index一开始是记录0，下面就是每次记录位移的距离与当前这个数字是多少，然后用stringbuffer进行叠加。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35.搜索插入位置</title>
    <link href="/2020/10/12/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/10/12/35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt;= target)&#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums.length;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>挺简单的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34.在排序数组中查找第一个和最后一个位置</title>
    <link href="/2020/10/12/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/10/12/34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        &#125;        <span class="hljs-keyword">int</span> left = coreFirst(nums,target);        <span class="hljs-keyword">int</span> right = coreLast(nums,target);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left,right&#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coreFirst</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;             <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span>(target == nums[mid])&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span>&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-keyword">if</span>(left != nums.length &amp;&amp; nums[left] == target)&#123;            <span class="hljs-keyword">return</span> left;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coreLast</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;             <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span>(target == nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &gt; nums[mid])&#123;                 left = mid+<span class="hljs-number">1</span>;             &#125;<span class="hljs-keyword">else</span>&#123;                 right = mid-<span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-keyword">if</span>(right != -<span class="hljs-number">1</span> &amp;&amp; nums[right] == target)&#123;            <span class="hljs-keyword">return</span> right;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实这道题一开始，我的想法并不对，用二分法找到对于二分法来说第一次出现的值，然后用–/++操作，找到这个值的开头和结尾，其实这样的时间复杂度根本不是logn，就是要利用二分法一直进行二分查找才可以。</p><p>那么还是定义两个函数，第一个找第一个位置，第二个找最后一个位置这样。有一种情况是需要特殊考虑的，就是3 4 5 5 这种情况，如果让你去找6这个target，最后也会导致left&gt;right循环退出，所以要判断一下 left != nums.length，如果相等，其实也是没找到，只不过只是数组越界了无法找到。</p><p>找第一个出现的位置的时候，left可能回到nums.length，找最后一个出现位置的时候，right可能会到-1，这些都是需要思考的事情。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33.搜索旋转排序数组</title>
    <link href="/2020/10/12/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2020/10/12/33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(left&lt;=right)&#123;            <span class="hljs-keyword">int</span> mid =(left+right)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;=nums[mid])&#123;                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;=target &amp;&amp; target&lt;=nums[mid])&#123;                    right = mid-<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    left = mid+<span class="hljs-number">1</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(nums[mid] &lt;=target &amp;&amp; target &lt;=nums[right])&#123;                    left = mid+<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    right = mid-<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是有一个点是一个旋转点，比如1 2 3 4 5 6 7 8 9</p><p>可能旋转成 8 9 1 2 3 4 5 6 7，也可能旋转成 3 4 5 6 7 8 9 1 2</p><p>关于这个中心点mid，就有两种不同的算法，如果在第一种nums[right] &gt;= nums[mid]，再如果target在介于中间，那么left = mid+1；如果不介于，那么right = mid-1，这样同样适用于 nums[left] &lt;= nums[mid] 也就是后者。</p><p>再用递归的思想，进行这道题的编写。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31.下一个排列</title>
    <link href="/2020/10/12/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2020/10/12/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =nums.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i+<span class="hljs-number">1</span>])&#123;                index = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;            reverse(<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,nums);            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;            <span class="hljs-keyword">if</span>(nums[j] &gt;nums[index])&#123;                swap(index,j,nums);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        reverse(index+<span class="hljs-number">1</span>,nums.length-<span class="hljs-number">1</span>,nums);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">int</span> temp = nums[left];        nums[left] = nums[right];        nums[right] = temp;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">while</span>(left&lt;right)&#123;            swap(left,right,nums);            left++;            right--;        &#125;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>个人认为这这种题就是看了才会</p><p>首先从后面往前找第一个当前位置比后一个位置小的数，记住该索引。</p><p>再从后面往前再找第一个比刚才内个索引大的这个位置，然后进行交换。</p><p>最后在从索引后面位置的一个，到结尾，进行翻转，得到正解。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <link href="/2020/10/12/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2020/10/12/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] != nums[j])&#123;                j++;                nums[j] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> j+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>双指针问题，如果当前位置i,j的值都一样，i继续，j不动，什么时候值不同，让j移到下一个位置，然后把当前位置j的值换成i，最后返回j+1，因为返回的是新的长度，所以j是从开始的，所以为j+1</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.两两交换链表中的节点</title>
    <link href="/2020/10/12/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/12/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode first = head;        ListNode second = head.next;                first.next = swapPairs(second.next);        second.next = first;                <span class="hljs-keyword">return</span> second;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是一个递归问题，弄明白就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.合并k个升序链表</title>
    <link href="/2020/10/12/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/10/12/23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode pre = result;                PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(            (o1,o2) -&gt;o1.val-o2.val        );        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;lists.length;++i)&#123;            <span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-keyword">null</span>)&#123;                queue.add(lists[i]);            &#125;        &#125;        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;            ListNode newnode = queue.poll();            pre.next = newnode;            pre =pre.next;            <span class="hljs-keyword">if</span>(newnode.next != <span class="hljs-keyword">null</span>)&#123;                queue.add(newnode.next);            &#125;        &#125;        <span class="hljs-keyword">return</span> result.next;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这是一道hard的类型题，我取巧用了优先级队列java中的api，记住一定要重写o1,o2也就是里面的规则。</p><p>然后其他的倒是没什么难度。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>hard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.有效的括号</title>
    <link href="/2020/10/12/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2020/10/12/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s.charAt(i) == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;                stack.push(s.charAt(i));            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty()  &amp;&amp; (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span>) || (s.charAt(i) == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) || (s.charAt(i) == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span>))&#123;                stack.pop();            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>考虑使用栈这种数据结构，先进后出。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <link href="/2020/10/12/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/12/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        result.next = head;        ListNode first= result;        ListNode second = result;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;            first = first.next;            n--;        &#125;        <span class="hljs-keyword">while</span>(first.next != <span class="hljs-keyword">null</span>)&#123;            first = first.next;            second = second.next;        &#125;        second.next = second.next.next;        <span class="hljs-keyword">return</span> result.next;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>像这种倒数链表的题，一般都要建立一个前驱节点指向头结点，再按照逻辑去做，进行递归或者是其他操作，得到题解。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.电话号码的字母组合</title>
    <link href="/2020/10/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2020/10/12/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    HashMap&lt;String,String&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits == <span class="hljs-keyword">null</span> || digits.length()&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> list;        &#125;        hashmap.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;abc&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;mno&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;tuv&quot;</span>);        hashmap.put(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>);        core(<span class="hljs-string">&quot;&quot;</span>,digits);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">core</span><span class="hljs-params">(String temp,String res)</span></span>&#123;        <span class="hljs-keyword">if</span>(res.length() == <span class="hljs-number">0</span>)&#123;            list.add(temp);        &#125;<span class="hljs-keyword">else</span>&#123;            String number = res.substring(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);            String choose = hashmap.get(number);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;choose.length();i++)&#123;                String newletter = temp + choose.substring(i,i+<span class="hljs-number">1</span>);                core(newletter,res.substring(<span class="hljs-number">1</span>));            &#125;        &#125;            &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：把所有的数字放入到hashmap中，形成一个key为number的字符串，value为真正字母的字符串。</p><p>第二： 相当于一次全排列，每次递归循环，出口就是需要遍历的字符串的长度为0</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和</title>
    <link href="/2020/10/12/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/10/12/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;                List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(nums);        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;<span class="hljs-number">3</span>)&#123;            <span class="hljs-keyword">return</span> lists;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;nums.length;++i)&#123;            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(nums[i] &gt;<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> lists;            &#125;            <span class="hljs-keyword">int</span> left = i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = nums.length-<span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> target = -nums[i];            <span class="hljs-keyword">while</span>(left&lt;right)&#123;                <span class="hljs-keyword">if</span>(nums[left] + nums[right] == target)&#123;                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                    list.add(nums[i]);                    list.add(nums[left]);                    list.add(nums[right]);                    lists.add(list);                    right--;                    left++;                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="hljs-number">1</span>])&#123;                        right--;                    &#125;                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="hljs-number">1</span>])&#123;                        left++;                    &#125;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left] + nums[right] &gt;target)&#123;                    right--;                &#125;<span class="hljs-keyword">else</span>&#123;                    left++;                   &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> lists;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一：一定要先进行排序</p><p>第二：一定进行剪枝，分别是第一个数已经大于0了，还有当得到一组等于0的解，继续向下剪枝。</p><p>第三：一定判断边界条件。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最长公共前缀</title>
    <link href="/2020/10/12/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2020/10/12/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span> || strs.length&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        &#125;        StringBuffer string = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i&lt;strs[<span class="hljs-number">0</span>].length();++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;strs.length;++j)&#123;                <span class="hljs-keyword">if</span>(i &gt;=strs[j].length() || strs[j].charAt(i) != strs[<span class="hljs-number">0</span>].charAt(i))&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(string);                &#125;            &#125;            string.append(strs[<span class="hljs-number">0</span>].charAt(i));        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(string);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是双层遍历，直接获取到结果。注意边界情况的判断即可。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.盛最多水的容器</title>
    <link href="/2020/10/12/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/10/12/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length&lt;<span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = height.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;right)&#123;            <span class="hljs-keyword">int</span> width = right-left;            <span class="hljs-keyword">int</span> high = height[left]&gt;height[right]?height[right--]:height[left++];            <span class="hljs-keyword">int</span> temp  = high*width;            max = Math.max(max,temp);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是双指针的用法，哪边小，从哪边往右走。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.回文数</title>
    <link href="/2020/10/12/9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/10/12/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">if</span>( x == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">if</span>(x &lt;<span class="hljs-number">0</span> || x%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(temp &lt; x)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            x = x/<span class="hljs-number">10</span>;            temp = temp*<span class="hljs-number">10</span>+tmp;        &#125;                <span class="hljs-keyword">return</span> (temp == x) || (temp/<span class="hljs-number">10</span> == x);    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>只需要相当于翻转一下，到一半即可，判断是不是回文数。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.整数反转</title>
    <link href="/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">int</span> tmp = x%<span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span>(temp &gt; Integer.MAX_VALUE/<span class="hljs-number">10</span> || (temp == Integer.MAX_VALUE &amp;&amp; tmp &gt;=Integer.MAX_VALUE%<span class="hljs-number">10</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>(temp &lt; Integer.MIN_VALUE/<span class="hljs-number">10</span> || (temp == Integer.MIN_VALUE/<span class="hljs-number">10</span> &amp;&amp;  tmp &lt;= Integer.MIN_VALUE%<span class="hljs-number">10</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            temp = temp*<span class="hljs-number">10</span>+tmp;            x = x/<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> temp;    &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是需要考虑一下整数溢出的情况，其他的就是一个翻转的过程。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length()&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;​    &#125;​    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;​    String result = <span class="hljs-string">&quot;&quot;</span>;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;​      String a = core(i,i,s);​      String b = core(i,i+<span class="hljs-number">1</span>,s);​      String temp = a.length()&gt;b.length()?a:b;​      <span class="hljs-keyword">if</span>(temp.length() &gt; length)&#123;​        result = temp;​        length = temp.length();​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">core</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,String s)</span></span>&#123;​    <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;​      left--;​      right++;​    &#125;​    <span class="hljs-keyword">return</span> s.substring(left+<span class="hljs-number">1</span>,right);  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在于substring的这个函数你需要的left+1这个参数，包括开始索引，到结束索引的前一个（所以就是不包含最后的索引），其他没有什么想要说的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length()&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​    &#125;​    HashMap&lt;Character,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();++i)&#123;​      <span class="hljs-keyword">int</span> temp = hashmap.getOrDefault(s.charAt(i),-<span class="hljs-number">1</span>);​      tmp = i-temp&gt;tmp?tmp+<span class="hljs-number">1</span>:i-temp;​      max = Math.max(max,tmp);​      hashmap.put(s.charAt(i),i);​    &#125;​    <span class="hljs-keyword">return</span> max;  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实这是一道动态规划的题，只不过加入了hashmap每次记录上一次单词出现的位置。</p><p>当前位置-上一次单词出现的位置与tmp中间量作为比较。如果大于，说明上一个单词不在当前的tmp中了，所以tmp+1；如果小于，说明上一个单词在tmp中，那么相当于进行了一次替换。</p><p>最后max是中间变量，从头到尾贯彻，作为最大值。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.两数相加</title>
    <link href="/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"></span><span class="hljs-comment"> \* Definition for singly-linked list.</span><span class="hljs-comment"></span><span class="hljs-comment"> \* public class ListNode &#123;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   int val;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode next;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode() &#123;&#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \*   ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> \* &#125;</span><span class="hljs-comment"></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;​    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span> &amp;&amp; l2 == <span class="hljs-keyword">null</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;​    &#125;​    ListNode result = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);​    ListNode pre = result;​    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;​    <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;​      <span class="hljs-keyword">int</span> val1 = l1 == <span class="hljs-keyword">null</span> ?<span class="hljs-number">0</span>:l1.val;​      <span class="hljs-keyword">int</span> val2 = l2 == <span class="hljs-keyword">null</span> ?<span class="hljs-number">0</span>:l2.val;​      <span class="hljs-keyword">int</span> temp = val1+val2+flag;​      ListNode newnode = <span class="hljs-keyword">new</span> ListNode(temp%<span class="hljs-number">10</span>);​      flag = temp / <span class="hljs-number">10</span>;​      pre.next = newnode;​      pre = pre.next;​      <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>)&#123;​        l1 = l1.next;​      &#125;​      <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>)&#123;​        l2 = l2.next;​      &#125;​    &#125;​    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)&#123;​      ListNode newnode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);​      pre.next =newnode;​    &#125;​    <span class="hljs-keyword">return</span> result.next;  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>没什么好说的，就是一开始用result作为最后输出的结尾，然后while的判断逻辑是l1,l2是否为空，最后判断一下当前的flag</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;​    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length&lt;=<span class="hljs-number">0</span>)&#123;​      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];​    &#125;​    HashMap&lt;Integer,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.length;++i)&#123;​      <span class="hljs-keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;​        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,hashmap.get(target-nums[i])&#125;;​      &#125;<span class="hljs-keyword">else</span>&#123;​        hashmap.put(nums[i],i);​      &#125;​    &#125;​    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];  &#125;&#125;</code></pre><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是用hashmap记录一下值，如果target-当前值存在于hashmap中，那么直接返回包括这两个数的索引。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程的状态与转换</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的定义，组成，组织方式，特征</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201011160211832.png"></p><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><p>程序：就是一个指令序列</p><p>早起计算机的时候，只支持单道程序，内存里面只有一个程序在跑，分为程序段（程序代码）和数据段（变量）。</p><p>引入多道程序之后，内存可以有多道程序运行，各个程序的代码、运算数据存放的位置不同，操作系统需要怎么才能找到程序的存放位置呢。</p><p>操作系统在每一个进程执行之前，都会创建一个叫PCB（进程控制块）的这样的一个东西，用来描述进程当前的信息。</p><p>程序段，数据段，pcb三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上创建进程实体中的pcb，而撤销进程，实质上也是撤销进程实体中的pcb</p><p>注意：<strong>pcb是进程存在的唯一标志</strong></p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><p>代码本身，指令序列</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>程序运行时使用、产生的运算数据。如全局变量，局部变量，宏定义的常量都存放在数据段内。</p><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>操作系统通过pcb来管理进程，因此pcb中应该包含操作系统对其进程管理所需的各种信息（相当于进程运行的元信息）。</p><p><img src="image-20201011161046798.png"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p>在一个系统中，通常有十级到千级的pcb，为了能对他们加以有效的管理，应该用适当的方式把这些pcb组织起来。</p><p>上面讲到的，进程的组成是哪几个部分组成了进程，进程的组织，是讲多进程之间的组织方式</p><p>一共分为两种：链接方式和索引方式</p><p><img src="image-20201011161413822.png"></p><h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p><img src="image-20201011161508401.png"></p><p>一共有三种指针，</p><p>执行指针：指向当前处于就绪态的进程</p><p>就绪队列指针：当前排队的进程，会根据优先级高低进行排列</p><p>阻塞队列指针：指向当前处阻塞态的进程</p><h2 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h2><p>同样也有三个指针，只不过指向的是一个表，而表中还会指向相应的pcb</p><p><img src="image-20201011162142337.png"></p><h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><p><img src="image-20201011162208795.png"></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201011162418120.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里规约禁止使用java内置Executors创建线程池</title>
    <link href="/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="提出几个问题"><a href="#提出几个问题" class="headerlink" title="提出几个问题"></a>提出几个问题</h1><p>1）线程池存在的意义</p><p>2）Executors创建线程池一共几种方式</p><p>3）ThreadPoolExecutor对象</p><p>4）线程池执行的逻辑和线程池参数关系</p><p>5）OOM会发生么</p><p>6）如何定义线程池参数</p><h1 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h1><p>线程池可以复用线程，每个线程的创建与销毁其实都会耗费资源的，所以有了池的概念，可以节省一些资源。</p><p>1）减少资源创建，减少内存开销</p><p>2）降低系统开销，创建线程需要时间，会延迟处理请求的速度</p><p>3）提高稳定性，避免无限创建线程引起的OOM（outofmemory）</p><h1 id="使用Exectors静态函数创建线程池"><a href="#使用Exectors静态函数创建线程池" class="headerlink" title="使用Exectors静态函数创建线程池"></a>使用Exectors静态函数创建线程池</h1><ul><li><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h1 id="Java的线程池"><a href="#Java的线程池" class="headerlink" title="Java的线程池"></a>Java的线程池</h1><p>在探究之前，我们需要明确一下，线程池的创建以及比较核心的七大参数。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                              <span class="hljs-keyword">int</span> maximumPoolSize,                              <span class="hljs-keyword">long</span> keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?                <span class="hljs-keyword">null</span> :                AccessController.getContext();        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;        <span class="hljs-keyword">this</span>.workQueue = workQueue;        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;    &#125;<span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), <span class="hljs-keyword">handler</span>);&#125;</code></pre><p>corePoolSize: 核心线程数</p><p>maximumPoolSize： 最大线程数</p><p>keepAliveTime： 非核心线程数，多长时间会被销毁</p><p>unit： 时间单位</p><p>workQueue： 任务队列，阻塞队列，用于存放已经提交但是未被执行的任务</p><p>threadFactory：线程工厂，用于创建线程</p><p>handler： 拒绝策略，任务想要添加进入线程池，线程池拒绝该任务所采取的相应策略</p><h1 id="workingQueue任务队列"><a href="#workingQueue任务队列" class="headerlink" title="workingQueue任务队列"></a>workingQueue任务队列</h1><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作，反之亦然。</p><p>4.PriorityBlockingQueue：具有优先级别的阻塞队列。</p><p>5.DelayedWorkQueue：延迟的阻塞队列。</p><h1 id="handler拒绝策略"><a href="#handler拒绝策略" class="headerlink" title="handler拒绝策略"></a>handler拒绝策略</h1><p>1.AbortPolicy：直接抛出异常，<strong>默认策略</strong></p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</p><p>4.DiscardPolicy：直接丢弃任务</p><h1 id="为什么阿里规约要求手动创建线程池"><a href="#为什么阿里规约要求手动创建线程池" class="headerlink" title="为什么阿里规约要求手动创建线程池"></a>为什么阿里规约要求手动创建线程池</h1><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>第一种newFixedThreadPool和newSingleThreadExecutor用的workingQueue都是LinkedBlockingQueue都是无界的阻塞队列，所以如果生产者一直大于消费者，队列不断膨胀，可能会导致内存溢出。</p><p>第二种newCachedThreadPool使用的是SynchronousQueue和newScheduledThreadPool使用的是DelayedWorkQueue。其中maximumPoolSize参数都为Integer.MAX_VALUE，所以空闲线程存活时间为0，当添加任务的速度大于线程池处理任务的速度，可能会创建大量的线程，消耗资源，甚至导致OOM。</p><h1 id="线程池执行任务逻辑"><a href="#线程池执行任务逻辑" class="headerlink" title="线程池执行任务逻辑"></a>线程池执行任务逻辑</h1><p>提交任务，如果当前核心线程没满，创建核心线程执行任务。若满了，看任务队列是否满，若无，添加队列。若已满，创建非核心线程执行任务，如果当前非核心线程也已经满了，那么进入到拒绝策略。</p>]]></content>
    
    
    <categories>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用 （六）</title>
    <link href="/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009205529316.png" alt="image-20201009205529316"></p><h1 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h1><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口，其中，程序接口由一组系统调用组成。</p><p>供给应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务，系统中各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配，IO操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p><img src="image-20201009211304714.png" alt="image-20201009211304714"></p><h1 id="系统调用和库函数的作用"><a href="#系统调用和库函数的作用" class="headerlink" title="系统调用和库函数的作用"></a>系统调用和库函数的作用</h1><p><img src="image-20201009211411935.png" alt="image-20201009211411935"></p><p>普通的应用程序可能调用库函数，库函数可能调用系统调用，也可能不调用系统调用。</p><h1 id="系统调用的背后的过程"><a href="#系统调用的背后的过程" class="headerlink" title="系统调用的背后的过程"></a>系统调用的背后的过程</h1><p>高级语言编译之后会变成汇编语言。</p><p><img src="image-20201009211748305.png" alt="image-20201009211748305"></p><p>传递系统调用参数 ——》 执行陷入指令（用户态） ——》 执行系统调用相应服务程序（核心态）——》返回用户程序</p><p>注意：</p><p>1）陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而cpu进入核心态</p><p>2）发出系统调用的请求是在用户态的，而对系统调用的相应处理是在核心态下进行的。</p><p>3） <strong>陷入指令是唯一一个在用户态下执行，而不能在核心态下面执行的指令</strong> </p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009212119178.png" alt="image-20201009212119178"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断和异常 （五）</title>
    <link href="/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009145255238.png" alt="image-20201009145255238"></p><h1 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h1><p>早起的计算机，比如博文操作系统的发展讲解的，单道处理系统，一次只能处理一个程序。所以各个程序只能串行的执行，系统资源利用率比较低。</p><p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p><p>举个例子，如果有多道程序运行，会有一个计时器，记录运行的时间。cpu收到计时部件发出的中断信号，切换为核心态为中断信号进行处理。操作系统内核会对中断信号进行处理，接受之后发现进程一的时间片时间到了，轮到进程二执行。进程二运行之后，发出系统调用（内中断信号），请求输出。cpu切换到内核态，对中断进行处理。进程二暂停等到打印机IO，换到进程三运行。等到打印机IO完成，设备向cpu发送外中断信号，cpu接收到io设备发来的中断信号，切换为核心态对中断进行处理。</p><h1 id="中断的概念和应用"><a href="#中断的概念和应用" class="headerlink" title="中断的概念和应用"></a>中断的概念和应用</h1><p>中断发生后，cpu会从用户态进入到内核态</p><p>中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</p><p>对于不同的中断信号，会进行不同的处理</p><p>发生了中断，就意味着操作系统介入，开展管理工作，由于操作系统的管理工作（比如进程切换、分配io设备等）需要使用特权指令，因此cpu要从用户态转换为内核态，中断可以使cpu从用户态切换为核心态，使操作系统或得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><p>用户态到核心态的切换，只能通过中断实现的，并且是唯一的方式。</p><p>核心态到用户态的转换，通过程序状态字psw标志位标识的。</p><h1 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h1><p><img src="image-20201009170728978.png" alt="image-20201009170728978"></p><h2 id="外中断处理过程"><a href="#外中断处理过程" class="headerlink" title="外中断处理过程"></a>外中断处理过程</h2><p><img src="image-20201009171311786.png" alt="image-20201009171311786"></p><p>执行完每一个指令的时候，cpu都要检查当前是否有外部中断信号。</p><p>如果检测到了外部中断信号，则需要保护被中断进程的cpu环境（程序状态字psw，程序计数器pc，各种寄存器状态）</p><p>根据中断信号类型转入相应的中断处理程序</p><p>恢复原进程的cpu环境并退出中断，返回原进程继续往下执行</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009171956319.png" alt="image-20201009171956319"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的运行机制与体系结构 （四）</title>
    <link href="/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009114046283.png"></p><h1 id="预备知识：指令"><a href="#预备知识：指令" class="headerlink" title="预备知识：指令"></a>预备知识：指令</h1><p>高级语言代码会被编译/解释之后变成机器语言指令（二进制）</p><p>一条高级语言的代码翻译过来可能会对应多条指令。</p><p><img src="image-20201009114232710.png"></p><p>上图可以看到，简单的一个让x加1的代码，对应了三条指令。</p><p>所以，指令也就是cpu能识别，执行的最基本的命令。</p><h2 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h2><p><img src="image-20201009114400229.png"></p><p>根据指令的优先级，我们可以把指令分成如上图的两种，特权指令（加法）与非特权指令（开辟空间）。</p><p>特权指令不允许普通用户执行，cpu执行的时候需要判断一下，当前的用户是否可以执行这条指令。</p><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><p><img src="image-20201009114522933.png"></p><p>用户态，就是普通用户，无法执行特权指令。核心态，指令都可以执行。</p><p>那么这个状态是用程序状态寄存器（psw）中的某标志位来标识当前处理器应该处于什么状态，如0是用户态，1是内核态。</p><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><p>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p><p>应用程序：为了保证系统安全的运行，普通应用程序只能执行非特权指令，运行在用户态。</p><h2 id="总结回顾指令"><a href="#总结回顾指令" class="headerlink" title="总结回顾指令"></a>总结回顾指令</h2><p><img src="image-20201009114855863.png"></p><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="image-20201009143510101.png"></p><p>时钟管理：实现计时功能</p><p>原语：是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性。</p><p>内核是计算机上的底层软件，是操作系统最基本、最核心的部分。</p><p>实现操作系统内核功能的那些程序就是内核程序。</p><p><img src="image-20201009143659151.png"></p><h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><p><img src="image-20201009143758466.png"></p><p>分为大内核与微内核。</p><p>大内核：高性能，但是内核代码庞大</p><p>微内核：内核功能少，结构清晰，但是如果需要一些调度，内核态和用户态之间需要频繁的进行切换，性能低。</p><p>这地方的理解就跟公司的管理层一样，大公司组织架构清晰，而小公司的leader可能要处理很多事情。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009144239267.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的发展 （三）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008230507825.png"></p><h1 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h1><p>计算机能识别二进制数（01），把数写在纸带机上，让计算机进行读取，处理之后，再输出纸带机上，最后输出。计算机的处理速度快，但是纸带机速度很慢，这样cpu空闲时间很多。另外，程序用纸袋机，这样不太方便。人机速度矛盾导致资源利用率低。</p><h1 id="单道批处理阶段"><a href="#单道批处理阶段" class="headerlink" title="单道批处理阶段"></a>单道批处理阶段</h1><p>引入脱机输入/输出技术（用磁带完成）并监督程序负责控制作业的输入/输出，速度比纸带机快很多。</p><p>单道批处理系统的优点：缓解了一定程度的人机矛盾，资源利用率有所提升。</p><p>缺点：内存中仅仅能有一道程序运行，只是该程序运行之后才能调入下一道程序。cpu还是有大量的时间空闲，资源利用虽然提高但是还是很低。</p><h1 id="多道批处理阶段"><a href="#多道批处理阶段" class="headerlink" title="多道批处理阶段"></a>多道批处理阶段</h1><p>还是利用磁带完成，但是是多道程序。操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行，各个程序并发执行。</p><p>优点：多道程序并发执行，共享计算机资源。资源利用率大幅度提升，cpu和其他资源保持忙碌状态，系统吞吐量增大。</p><p>缺点：没有人机交互，用户响应时间长（用户提交作业之后只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h1 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h1><p>计算机以时间片为单位轮流的为各个用户/作业服务，各个用户可以通过终端与计算机进行交互。</p><p>缺点：不能优先处理一些紧急任务，操作系统对所有的用户和作业都是公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h1 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h1><p>优先响应一些紧急任务，某些紧急任务不需要时间排队。</p><p>在实时操作系统的控制下，计算机接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><h1 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h1><h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机结合起来，实现数据传送等功能，实现网络中各种资源的共享（文件的共享）和各台计算机之间的通信。</p><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>主要特点是分布性和并行性，系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行/协同完成这个任务。</p><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><p>windows xp / MacOs 方便个人使用</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009113711074.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的四个特征 （二）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008223341290.png"></p><p>并发和共享是最基本的两个特征，二者互为存在条件。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发是指两个或者多个事件在同一个时间间隔内发生，这些事件宏观上是同时发生的，但是在微观上其实是互相交替发生的（一个cpu运行两个进程）。</p><p>特别注意的是并行，指两个或者多个事件在同一时刻同时发生（双核cpu执行两个进程）。</p><p>操作系统的并发性，是指计算机系统中同时存在着多个运行着的程序。</p><p>一个单核处理机（cpu）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但是宏观看上去就好像在同时执行）。事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p><p>当今的计算机，虽然cpu有很多核，但是操作系统的并发性还是必不可少的，远远不够使用。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><p>共享即是共享资源，是指系统中的资源可供内存中多个并发执行的进程使用。</p><p>资源分为两种，互斥共享与同时共享。</p><p>互斥共享，是指同一时间只能允许一个进程访问资源。</p><p>同时共享，是指同一时间允许多个进程访问资源。</p><p>生活中的实例，互斥共享——摄像头，同时共享——发送文件。</p><h1 id="共享与并发"><a href="#共享与并发" class="headerlink" title="共享与并发"></a>共享与并发</h1><p>并发性是指计算机系统中同时存在着多个运行的程序。</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>并发和共享是互为存在条件的。</p><h1 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h1><p>是指把一个物理上的实体对应为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受的。</p><p>一个程序需要分配内存才能运行，一个游戏如果8G，电脑有4G内存。程序同时运行内存远超于4G，利用了<strong>虚拟存储器技术</strong>，所以可以同时运行。（空分复用技术）</p><p>多个程序需要被分配多个cpu才能运行，单核的cpu是如何运行程序的呢？采用的是<strong>虚拟处理器技术</strong>，使用户看起来一共有6个cpu在同时服务。（时分复用技术）</p><p><img src="image-20201008225118513.png"></p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步是指，在多道程序下，允许多个程序并发执行，但是由于资源有限，进程的执行不一定是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008225444396.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的概念（定义）目标与功能 （一）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="大家都熟悉的操作系统"><a href="#大家都熟悉的操作系统" class="headerlink" title="大家都熟悉的操作系统"></a>大家都熟悉的操作系统</h1><p>如下图，我们可以看到常用的操作系统。不管是pc端还是移动端。</p><p><img src="image-20201008110624343.png"></p><h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008110710543.png"></p><h1 id="操作系统的概念和定义"><a href="#操作系统的概念和定义" class="headerlink" title="操作系统的概念和定义"></a>操作系统的概念和定义</h1><p>一台电脑的诞生：一台裸机  ——》 安装windows操作系统 ——》安装游戏 ——》启动游戏进行游戏</p><p>硬件有我们的cpu/内存/硬盘</p><p>应用程序有我们常用的微信QQ百度云</p><p>那么操作系统的概念与定义我们可想而知。</p><p>1）负责管理协同硬件/软件等计算机资源的工作</p><p>2）为上层的应用程序，用户提高简单易用的服务</p><p>3）操作系统是系统软件，不是硬件</p><p>结合以上三条就是：</p><p><strong>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机中最基本的系统软件。</strong></p><p><img src="image-20201008110858123.png"></p><h1 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h1><h2 id="作为系统资源的管理者"><a href="#作为系统资源的管理者" class="headerlink" title="作为系统资源的管理者"></a>作为系统资源的管理者</h2><p>补充一个小知识，如果我们使用QQ与朋友进行聊天。</p><p>第一步：找到QQ文件的位置（路径） <strong>文件管理</strong> 打开找到QQ.exe这个程序的存放位置</p><p>第二步：双击打开exe文件  <strong>存储器管理</strong> 需要把相应的程序加载到内存中</p><p>第三步：QQ程序开始运行 <strong>处理器管理</strong> 对应的进程被处理器管理</p><p>第四步：开始使用QQ聊天 <strong>设备管理</strong> 分配给QQ聊天（就比如我们使用牛客网进行面试的时候，只能一个网页开启视频）</p><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p>命令接口： 允许用户使用</p><p>程序接口： 允许用户通过程序间接调用</p><p>gui： 图像化界面</p><h3 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h3><p>联机命令接口：用户说一句，系统做一句。cmd</p><p>脱机命令接口：用户说一堆，系统做一堆。shell脚本</p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>允许用户通过程序间接调用，由一组系统调用组成（程序接口=系统调用）</p><p>程序中调用user32.dll（该调用过程为系统调用，系统调用又称为广义指令）</p><h3 id="gui图形用户界面"><a href="#gui图形用户界面" class="headerlink" title="gui图形用户界面"></a>gui图形用户界面</h3><p>不需要参数，只需要鼠标与键盘的配合即可</p><h2 id="作为最接近硬件的层次"><a href="#作为最接近硬件的层次" class="headerlink" title="作为最接近硬件的层次"></a>作为最接近硬件的层次</h2><p>通常把覆盖软件的机器成为扩充机器，又称之为虚拟机。</p><p>硬件都是一些零零散散的，而操作系统就可以利用这些硬件工具做想做的事情，封装思想。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008140933785.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/06/hello-world/"/>
    <url>/2020/10/06/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>程序人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
