<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>7.整数反转</title>
    <link href="/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/10/11/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>`class Solution {</p><p>  public String longestPalindrome(String s) {</p><p>​    if(s == null || s.length()&lt;=0){</p><p>​      return “”;</p><p>​    }</p><p>​    int length = 0;</p><p>​    String result = “”;</p><p>​    for(int i = 0;i&lt;s.length();++i){</p><p>​      String a = core(i,i,s);</p><p>​      String b = core(i,i+1,s);</p><p>​      String temp = a.length()&gt;b.length()?a:b;</p><p>​      if(temp.length() &gt; length){</p><p>​        result = temp;</p><p>​        length = temp.length();</p><p>​      }</p><p>​    }</p><p>​    return result;</p><p>  }</p><p>  public String core(int left,int right,String s){</p><p>​    while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right)){</p><p>​      left–;</p><p>​      right++;</p><p>​    }</p><p>​    return s.substring(left+1,right);</p><p>  }</p><p>}`</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在于substring的这个函数你需要的left+1这个参数，包括开始索引，到结束索引的前一个（所以就是不包含最后的索引），其他没有什么想要说的。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/10/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>`class Solution {</p><p>  public int lengthOfLongestSubstring(String s) {</p><p>​    if(s == null || s.length()&lt;=0){</p><p>​      return 0;</p><p>​    }</p><p>​    HashMap&lt;Character,Integer&gt; hashmap = new HashMap&lt;&gt;();</p><p>​    int max = 0;</p><p>​    int tmp = 0;</p><p>​    for(int i = 0;i&lt;s.length();++i){</p><p>​      int temp = hashmap.getOrDefault(s.charAt(i),-1);</p><p>​      tmp = i-temp&gt;tmp?tmp+1:i-temp;</p><p>​      max = Math.max(max,tmp);</p><p>​      hashmap.put(s.charAt(i),i);</p><p>​    }</p><p>​    return max;</p><p>  }</p><p>}`</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实这是一道动态规划的题，只不过加入了hashmap每次记录上一次单词出现的位置。</p><p>当前位置-上一次单词出现的位置与tmp中间量作为比较。如果大于，说明上一个单词不在当前的tmp中了，所以tmp+1；如果小于，说明上一个单词在tmp中，那么相当于进行了一次替换。</p><p>最后max是中间变量，从头到尾贯彻，作为最大值。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.两数相加</title>
    <link href="/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2020/10/11/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>`/**</p><p> * Definition for singly-linked list.</p><p> * public class ListNode {</p><p> *   int val;</p><p> *   ListNode next;</p><p> *   ListNode() {}</p><p> *   ListNode(int val) { this.val = val; }</p><p> *   ListNode(int val, ListNode next) { this.val = val; this.next = next; }</p><p> * }</p><p> */</p><p>class Solution {</p><p>  public ListNode addTwoNumbers(ListNode l1, ListNode l2) {</p><p>​    if(l1 == null &amp;&amp; l2 == null){</p><p>​      return null;</p><p>​    }</p><p>​    ListNode result = new ListNode(-1);</p><p>​    ListNode pre = result;</p><p>​    int flag = 0;</p><p>​    while(l1 != null || l2 != null){</p><p>​      int val1 = l1 == null ?0:l1.val;</p><p>​      int val2 = l2 == null ?0:l2.val;</p><p>​      int temp = val1+val2+flag;</p><p>​      ListNode newnode = new ListNode(temp%10);</p><p>​      flag = temp / 10;</p><p>​      pre.next = newnode;</p><p>​      pre = pre.next;</p><p>​      if(l1 != null){</p><p>​        l1 = l1.next;</p><p>​      }</p><p>​      if(l2 != null){</p><p>​        l2 = l2.next;</p><p>​      }</p><p>​    }</p><p>​    if(flag == 1){</p><p>​      ListNode newnode = new ListNode(1);</p><p>​      pre.next =newnode;</p><p>​    }</p><p>​    return result.next;</p><p>  }</p><p>}`</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>没什么好说的，就是一开始用result作为最后输出的结尾，然后while的判断逻辑是l1,l2是否为空，最后判断一下当前的flag</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>mid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/10/11/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>`class Solution {</p><p>  public int[] twoSum(int[] nums, int target) {</p><p>​    if(nums == null || nums.length&lt;=0){</p><p>​      return new int[2];</p><p>​    }</p><p>​    HashMap&lt;Integer,Integer&gt; hashmap = new HashMap&lt;&gt;();</p><p>​    for(int i = 0;i&lt;nums.length;++i){</p><p>​      if(hashmap.containsKey(target-nums[i])){</p><p>​        return new int[]{i,hashmap.get(target-nums[i])};</p><p>​      }else{</p><p>​        hashmap.put(nums[i],i);</p><p>​      }</p><p>​    }</p><p>​    return new int[2];</p><p>  }</p><p>}`</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>就是用hashmap记录一下值，如果target-当前值存在于hashmap中，那么直接返回包括这两个数的索引。</p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>easy</tag>
      
      <tag>力扣</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程的状态与转换</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的定义，组成，组织方式，特征</title>
    <link href="/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%BB%84%E6%88%90%EF%BC%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201011160211832.png"></p><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><p>程序：就是一个指令序列</p><p>早起计算机的时候，只支持单道程序，内存里面只有一个程序在跑，分为程序段（程序代码）和数据段（变量）。</p><p>引入多道程序之后，内存可以有多道程序运行，各个程序的代码、运算数据存放的位置不同，操作系统需要怎么才能找到程序的存放位置呢。</p><p>操作系统在每一个进程执行之前，都会创建一个叫PCB（进程控制块）的这样的一个东西，用来描述进程当前的信息。</p><p>程序段，数据段，pcb三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上创建进程实体中的pcb，而撤销进程，实质上也是撤销进程实体中的pcb</p><p>注意：<strong>pcb是进程存在的唯一标志</strong></p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><p>代码本身，指令序列</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>程序运行时使用、产生的运算数据。如全局变量，局部变量，宏定义的常量都存放在数据段内。</p><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>操作系统通过pcb来管理进程，因此pcb中应该包含操作系统对其进程管理所需的各种信息（相当于进程运行的元信息）。</p><p><img src="image-20201011161046798.png"></p><h1 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h1><p>在一个系统中，通常有十级到千级的pcb，为了能对他们加以有效的管理，应该用适当的方式把这些pcb组织起来。</p><p>上面讲到的，进程的组成是哪几个部分组成了进程，进程的组织，是讲多进程之间的组织方式</p><p>一共分为两种：链接方式和索引方式</p><p><img src="image-20201011161413822.png"></p><h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p><img src="image-20201011161508401.png"></p><p>一共有三种指针，</p><p>执行指针：指向当前处于就绪态的进程</p><p>就绪队列指针：当前排队的进程，会根据优先级高低进行排列</p><p>阻塞队列指针：指向当前处阻塞态的进程</p><h2 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h2><p>同样也有三个指针，只不过指向的是一个表，而表中还会指向相应的pcb</p><p><img src="image-20201011162142337.png"></p><h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><p><img src="image-20201011162208795.png"></p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201011162418120.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里规约禁止使用java内置Executors创建线程池</title>
    <link href="/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/10/09/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8java%E5%86%85%E7%BD%AEExecutors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="提出几个问题"><a href="#提出几个问题" class="headerlink" title="提出几个问题"></a>提出几个问题</h1><p>1）线程池存在的意义</p><p>2）Executors创建线程池一共几种方式</p><p>3）ThreadPoolExecutor对象</p><p>4）线程池执行的逻辑和线程池参数关系</p><p>5）OOM会发生么</p><p>6）如何定义线程池参数</p><h1 id="线程池的意义"><a href="#线程池的意义" class="headerlink" title="线程池的意义"></a>线程池的意义</h1><p>线程池可以复用线程，每个线程的创建与销毁其实都会耗费资源的，所以有了池的概念，可以节省一些资源。</p><p>1）减少资源创建，减少内存开销</p><p>2）降低系统开销，创建线程需要时间，会延迟处理请求的速度</p><p>3）提高稳定性，避免无限创建线程引起的OOM（outofmemory）</p><h1 id="使用Exectors静态函数创建线程池"><a href="#使用Exectors静态函数创建线程池" class="headerlink" title="使用Exectors静态函数创建线程池"></a>使用Exectors静态函数创建线程池</h1><ul><li><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li><strong>newFixedThreadPool</strong> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong>newScheduledThreadPool</strong> 创建一个定长线程池，支持定时及周期性任务执行。</li><li><strong>newSingleThreadExecutor</strong> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h1 id="Java的线程池"><a href="#Java的线程池" class="headerlink" title="Java的线程池"></a>Java的线程池</h1><p>在探究之前，我们需要明确一下，线程池的创建以及比较核心的七大参数。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                              <span class="hljs-keyword">int</span> maximumPoolSize,                              <span class="hljs-keyword">long</span> keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?                <span class="hljs-keyword">null</span> :                AccessController.getContext();        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;        <span class="hljs-keyword">this</span>.workQueue = workQueue;        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;    &#125;<span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>) &#123;    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,         Executors.defaultThreadFactory(), <span class="hljs-keyword">handler</span>);&#125;</code></pre><p>corePoolSize: 核心线程数</p><p>maximumPoolSize： 最大线程数</p><p>keepAliveTime： 非核心线程数，多长时间会被销毁</p><p>unit： 时间单位</p><p>workQueue： 任务队列，阻塞队列，用于存放已经提交但是未被执行的任务</p><p>threadFactory：线程工厂，用于创建线程</p><p>handler： 拒绝策略，任务想要添加进入线程池，线程池拒绝该任务所采取的相应策略</p><h1 id="workingQueue任务队列"><a href="#workingQueue任务队列" class="headerlink" title="workingQueue任务队列"></a>workingQueue任务队列</h1><p>1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。</p><p>2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。</p><p>3.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作，反之亦然。</p><p>4.PriorityBlockingQueue：具有优先级别的阻塞队列。</p><p>5.DelayedWorkQueue：延迟的阻塞队列。</p><h1 id="handler拒绝策略"><a href="#handler拒绝策略" class="headerlink" title="handler拒绝策略"></a>handler拒绝策略</h1><p>1.AbortPolicy：直接抛出异常，<strong>默认策略</strong></p><p>2.CallerRunsPolicy：用调用者所在的线程来执行任务</p><p>3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</p><p>4.DiscardPolicy：直接丢弃任务</p><h1 id="为什么阿里规约要求手动创建线程池"><a href="#为什么阿里规约要求手动创建线程池" class="headerlink" title="为什么阿里规约要求手动创建线程池"></a>为什么阿里规约要求手动创建线程池</h1><p>Executors各个方法的弊端：<br>1）newFixedThreadPool和newSingleThreadExecutor:<br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2）newCachedThreadPool和newScheduledThreadPool:<br>  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p><p>第一种newFixedThreadPool和newSingleThreadExecutor用的workingQueue都是LinkedBlockingQueue都是无界的阻塞队列，所以如果生产者一直大于消费者，队列不断膨胀，可能会导致内存溢出。</p><p>第二种newCachedThreadPool使用的是SynchronousQueue和newScheduledThreadPool使用的是DelayedWorkQueue。其中maximumPoolSize参数都为Integer.MAX_VALUE，所以空闲线程存活时间为0，当添加任务的速度大于线程池处理任务的速度，可能会创建大量的线程，消耗资源，甚至导致OOM。</p><h1 id="线程池执行任务逻辑"><a href="#线程池执行任务逻辑" class="headerlink" title="线程池执行任务逻辑"></a>线程池执行任务逻辑</h1><p>提交任务，如果当前核心线程没满，创建核心线程执行任务。若满了，看任务队列是否满，若无，添加队列。若已满，创建非核心线程执行任务，如果当前非核心线程也已经满了，那么进入到拒绝策略。</p>]]></content>
    
    
    <categories>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用 （六）</title>
    <link href="/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009205529316.png" alt="image-20201009205529316"></p><h1 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h1><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口，其中，程序接口由一组系统调用组成。</p><p>供给应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务，系统中各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配，IO操作，文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p><img src="image-20201009211304714.png" alt="image-20201009211304714"></p><h1 id="系统调用和库函数的作用"><a href="#系统调用和库函数的作用" class="headerlink" title="系统调用和库函数的作用"></a>系统调用和库函数的作用</h1><p><img src="image-20201009211411935.png" alt="image-20201009211411935"></p><p>普通的应用程序可能调用库函数，库函数可能调用系统调用，也可能不调用系统调用。</p><h1 id="系统调用的背后的过程"><a href="#系统调用的背后的过程" class="headerlink" title="系统调用的背后的过程"></a>系统调用的背后的过程</h1><p>高级语言编译之后会变成汇编语言。</p><p><img src="image-20201009211748305.png" alt="image-20201009211748305"></p><p>传递系统调用参数 ——》 执行陷入指令（用户态） ——》 执行系统调用相应服务程序（核心态）——》返回用户程序</p><p>注意：</p><p>1）陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而cpu进入核心态</p><p>2）发出系统调用的请求是在用户态的，而对系统调用的相应处理是在核心态下进行的。</p><p>3） <strong>陷入指令是唯一一个在用户态下执行，而不能在核心态下面执行的指令</strong> </p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009212119178.png" alt="image-20201009212119178"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断和异常 （五）</title>
    <link href="/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/10/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009145255238.png" alt="image-20201009145255238"></p><h1 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a>中断机制的诞生</h1><p>早起的计算机，比如博文操作系统的发展讲解的，单道处理系统，一次只能处理一个程序。所以各个程序只能串行的执行，系统资源利用率比较低。</p><p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p><p>举个例子，如果有多道程序运行，会有一个计时器，记录运行的时间。cpu收到计时部件发出的中断信号，切换为核心态为中断信号进行处理。操作系统内核会对中断信号进行处理，接受之后发现进程一的时间片时间到了，轮到进程二执行。进程二运行之后，发出系统调用（内中断信号），请求输出。cpu切换到内核态，对中断进行处理。进程二暂停等到打印机IO，换到进程三运行。等到打印机IO完成，设备向cpu发送外中断信号，cpu接收到io设备发来的中断信号，切换为核心态对中断进行处理。</p><h1 id="中断的概念和应用"><a href="#中断的概念和应用" class="headerlink" title="中断的概念和应用"></a>中断的概念和应用</h1><p>中断发生后，cpu会从用户态进入到内核态</p><p>中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</p><p>对于不同的中断信号，会进行不同的处理</p><p>发生了中断，就意味着操作系统介入，开展管理工作，由于操作系统的管理工作（比如进程切换、分配io设备等）需要使用特权指令，因此cpu要从用户态转换为内核态，中断可以使cpu从用户态切换为核心态，使操作系统或得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><p>用户态到核心态的切换，只能通过中断实现的，并且是唯一的方式。</p><p>核心态到用户态的转换，通过程序状态字psw标志位标识的。</p><h1 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h1><p><img src="image-20201009170728978.png" alt="image-20201009170728978"></p><h2 id="外中断处理过程"><a href="#外中断处理过程" class="headerlink" title="外中断处理过程"></a>外中断处理过程</h2><p><img src="image-20201009171311786.png" alt="image-20201009171311786"></p><p>执行完每一个指令的时候，cpu都要检查当前是否有外部中断信号。</p><p>如果检测到了外部中断信号，则需要保护被中断进程的cpu环境（程序状态字psw，程序计数器pc，各种寄存器状态）</p><p>根据中断信号类型转入相应的中断处理程序</p><p>恢复原进程的cpu环境并退出中断，返回原进程继续往下执行</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009171956319.png" alt="image-20201009171956319"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的运行机制与体系结构 （四）</title>
    <link href="/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201009114046283.png"></p><h1 id="预备知识：指令"><a href="#预备知识：指令" class="headerlink" title="预备知识：指令"></a>预备知识：指令</h1><p>高级语言代码会被编译/解释之后变成机器语言指令（二进制）</p><p>一条高级语言的代码翻译过来可能会对应多条指令。</p><p><img src="image-20201009114232710.png"></p><p>上图可以看到，简单的一个让x加1的代码，对应了三条指令。</p><p>所以，指令也就是cpu能识别，执行的最基本的命令。</p><h2 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h2><p><img src="image-20201009114400229.png"></p><p>根据指令的优先级，我们可以把指令分成如上图的两种，特权指令（加法）与非特权指令（开辟空间）。</p><p>特权指令不允许普通用户执行，cpu执行的时候需要判断一下，当前的用户是否可以执行这条指令。</p><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><p><img src="image-20201009114522933.png"></p><p>用户态，就是普通用户，无法执行特权指令。核心态，指令都可以执行。</p><p>那么这个状态是用程序状态寄存器（psw）中的某标志位来标识当前处理器应该处于什么状态，如0是用户态，1是内核态。</p><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><p>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p><p>应用程序：为了保证系统安全的运行，普通应用程序只能执行非特权指令，运行在用户态。</p><h2 id="总结回顾指令"><a href="#总结回顾指令" class="headerlink" title="总结回顾指令"></a>总结回顾指令</h2><p><img src="image-20201009114855863.png"></p><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="image-20201009143510101.png"></p><p>时钟管理：实现计时功能</p><p>原语：是一种特殊的程序，是最接近硬件的部分，这种程序的运行具有原子性。</p><p>内核是计算机上的底层软件，是操作系统最基本、最核心的部分。</p><p>实现操作系统内核功能的那些程序就是内核程序。</p><p><img src="image-20201009143659151.png"></p><h1 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h1><p><img src="image-20201009143758466.png"></p><p>分为大内核与微内核。</p><p>大内核：高性能，但是内核代码庞大</p><p>微内核：内核功能少，结构清晰，但是如果需要一些调度，内核态和用户态之间需要频繁的进行切换，性能低。</p><p>这地方的理解就跟公司的管理层一样，大公司组织架构清晰，而小公司的leader可能要处理很多事情。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201009144239267.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的发展 （三）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008230507825.png"></p><h1 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h1><p>计算机能识别二进制数（01），把数写在纸带机上，让计算机进行读取，处理之后，再输出纸带机上，最后输出。计算机的处理速度快，但是纸带机速度很慢，这样cpu空闲时间很多。另外，程序用纸袋机，这样不太方便。人机速度矛盾导致资源利用率低。</p><h1 id="单道批处理阶段"><a href="#单道批处理阶段" class="headerlink" title="单道批处理阶段"></a>单道批处理阶段</h1><p>引入脱机输入/输出技术（用磁带完成）并监督程序负责控制作业的输入/输出，速度比纸带机快很多。</p><p>单道批处理系统的优点：缓解了一定程度的人机矛盾，资源利用率有所提升。</p><p>缺点：内存中仅仅能有一道程序运行，只是该程序运行之后才能调入下一道程序。cpu还是有大量的时间空闲，资源利用虽然提高但是还是很低。</p><h1 id="多道批处理阶段"><a href="#多道批处理阶段" class="headerlink" title="多道批处理阶段"></a>多道批处理阶段</h1><p>还是利用磁带完成，但是是多道程序。操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行，各个程序并发执行。</p><p>优点：多道程序并发执行，共享计算机资源。资源利用率大幅度提升，cpu和其他资源保持忙碌状态，系统吞吐量增大。</p><p>缺点：没有人机交互，用户响应时间长（用户提交作业之后只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h1 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h1><p>计算机以时间片为单位轮流的为各个用户/作业服务，各个用户可以通过终端与计算机进行交互。</p><p>缺点：不能优先处理一些紧急任务，操作系统对所有的用户和作业都是公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h1 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h1><p>优先响应一些紧急任务，某些紧急任务不需要时间排队。</p><p>在实时操作系统的控制下，计算机接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><h1 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h1><h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机结合起来，实现数据传送等功能，实现网络中各种资源的共享（文件的共享）和各台计算机之间的通信。</p><h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>主要特点是分布性和并行性，系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行/协同完成这个任务。</p><h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><p>windows xp / MacOs 方便个人使用</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="C:\Users\mmz\AppData\Roaming\Typora\typora-user-images\image-20201009113711074.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的四个特征 （二）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/</url>
    
    <content type="html"><![CDATA[<h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008223341290.png"></p><p>并发和共享是最基本的两个特征，二者互为存在条件。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发是指两个或者多个事件在同一个时间间隔内发生，这些事件宏观上是同时发生的，但是在微观上其实是互相交替发生的（一个cpu运行两个进程）。</p><p>特别注意的是并行，指两个或者多个事件在同一时刻同时发生（双核cpu执行两个进程）。</p><p>操作系统的并发性，是指计算机系统中同时存在着多个运行着的程序。</p><p>一个单核处理机（cpu）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但是宏观看上去就好像在同时执行）。事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p><p>当今的计算机，虽然cpu有很多核，但是操作系统的并发性还是必不可少的，远远不够使用。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><p>共享即是共享资源，是指系统中的资源可供内存中多个并发执行的进程使用。</p><p>资源分为两种，互斥共享与同时共享。</p><p>互斥共享，是指同一时间只能允许一个进程访问资源。</p><p>同时共享，是指同一时间允许多个进程访问资源。</p><p>生活中的实例，互斥共享——摄像头，同时共享——发送文件。</p><h1 id="共享与并发"><a href="#共享与并发" class="headerlink" title="共享与并发"></a>共享与并发</h1><p>并发性是指计算机系统中同时存在着多个运行的程序。</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>并发和共享是互为存在条件的。</p><h1 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h1><p>是指把一个物理上的实体对应为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受的。</p><p>一个程序需要分配内存才能运行，一个游戏如果8G，电脑有4G内存。程序同时运行内存远超于4G，利用了<strong>虚拟存储器技术</strong>，所以可以同时运行。（空分复用技术）</p><p>多个程序需要被分配多个cpu才能运行，单核的cpu是如何运行程序的呢？采用的是<strong>虚拟处理器技术</strong>，使用户看起来一共有6个cpu在同时服务。（时分复用技术）</p><p><img src="image-20201008225118513.png"></p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步是指，在多道程序下，允许多个程序并发执行，但是由于资源有限，进程的执行不一定是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008225444396.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统的概念（定义）目标与功能 （一）</title>
    <link href="/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="大家都熟悉的操作系统"><a href="#大家都熟悉的操作系统" class="headerlink" title="大家都熟悉的操作系统"></a>大家都熟悉的操作系统</h1><p>如下图，我们可以看到常用的操作系统。不管是pc端还是移动端。</p><p><img src="image-20201008110624343.png"></p><h1 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h1><p><img src="image-20201008110710543.png"></p><h1 id="操作系统的概念和定义"><a href="#操作系统的概念和定义" class="headerlink" title="操作系统的概念和定义"></a>操作系统的概念和定义</h1><p>一台电脑的诞生：一台裸机  ——》 安装windows操作系统 ——》安装游戏 ——》启动游戏进行游戏</p><p>硬件有我们的cpu/内存/硬盘</p><p>应用程序有我们常用的微信QQ百度云</p><p>那么操作系统的概念与定义我们可想而知。</p><p>1）负责管理协同硬件/软件等计算机资源的工作</p><p>2）为上层的应用程序，用户提高简单易用的服务</p><p>3）操作系统是系统软件，不是硬件</p><p>结合以上三条就是：</p><p><strong>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机中最基本的系统软件。</strong></p><p><img src="image-20201008110858123.png"></p><h1 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h1><h2 id="作为系统资源的管理者"><a href="#作为系统资源的管理者" class="headerlink" title="作为系统资源的管理者"></a>作为系统资源的管理者</h2><p>补充一个小知识，如果我们使用QQ与朋友进行聊天。</p><p>第一步：找到QQ文件的位置（路径） <strong>文件管理</strong> 打开找到QQ.exe这个程序的存放位置</p><p>第二步：双击打开exe文件  <strong>存储器管理</strong> 需要把相应的程序加载到内存中</p><p>第三步：QQ程序开始运行 <strong>处理器管理</strong> 对应的进程被处理器管理</p><p>第四步：开始使用QQ聊天 <strong>设备管理</strong> 分配给QQ聊天（就比如我们使用牛客网进行面试的时候，只能一个网页开启视频）</p><h2 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h2><p>命令接口： 允许用户使用</p><p>程序接口： 允许用户通过程序间接调用</p><p>gui： 图像化界面</p><h3 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h3><p>联机命令接口：用户说一句，系统做一句。cmd</p><p>脱机命令接口：用户说一堆，系统做一堆。shell脚本</p><h3 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h3><p>允许用户通过程序间接调用，由一组系统调用组成（程序接口=系统调用）</p><p>程序中调用user32.dll（该调用过程为系统调用，系统调用又称为广义指令）</p><h3 id="gui图形用户界面"><a href="#gui图形用户界面" class="headerlink" title="gui图形用户界面"></a>gui图形用户界面</h3><p>不需要参数，只需要鼠标与键盘的配合即可</p><h2 id="作为最接近硬件的层次"><a href="#作为最接近硬件的层次" class="headerlink" title="作为最接近硬件的层次"></a>作为最接近硬件的层次</h2><p>通常把覆盖软件的机器成为扩充机器，又称之为虚拟机。</p><p>硬件都是一些零零散散的，而操作系统就可以利用这些硬件工具做想做的事情，封装思想。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="image-20201008140933785.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/06/hello-world/"/>
    <url>/2020/10/06/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>程序人生</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序人生</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
